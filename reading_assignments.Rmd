# Purpose

To work out how to read in and work with the assignments.

```{r setup}
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, message = FALSE, verbose = TRUE)
```

# Lots of Assignments

```{r assignment_files}
library(SIRM.FTMS.peakCharacterization)
library(visualizationQualityControl)
print(interactive())
print(options("dplyr.show_progress"))
```

```{r read_them_in}
assigned_files <- dir("~/data/cesb_data/assignments/lung_cancer_matched_tissue/2018-01-04-000000", full.names = TRUE)

assigned_data <- purrr::map(assigned_files, read_smirfe_assignment)
```

And now we can grab the information for peaks associated with each IMF.

```{r extract_peaks}
extracted_data <- extract_peaks(assigned_data)
```

We know there are a ton of duplicate peaks in here. Lets see if we can find them,
and if they consistently have the same IMFs.

```{r dup_peaks}
extracted_data2 <- find_duplicate_peaks(extracted_data)
```

# Do Some Analysis

```{r filter_peaks}
peak_height <- extracted_data2$height
peak_height[is.na(peak_height)] <- 0

sample_class <- data.frame(sample = colnames(peak_height), disease = "cancer", stringsAsFactors = FALSE)
sample_class[grepl("Npos", sample_class$sample, ignore.case = TRUE), "disease"] <- "normal"
rownames(sample_class) <- sample_class$sample



peak_height <- t(keep_non_zero_percentage(t(peak_height), sample_classes = sample_class$disease, keep_num = 0.25, zero_value = 0))

for (isample in colnames(peak_height)) {
  peak_height[, isample] <- peak_height[, isample] / extracted_data2$tic[isample]
}
```

```{r dopca}
pca_height <- prcomp(t(log1p(peak_height)), center = TRUE, scale. = FALSE)

visqc_pca(pca_height)


visqc_pca(pca_height, groups = sample_class$disease, labels = sample_class$sample)
```

```{r correlation}
corr_height <- pairwise_correlation(t(log1p(peak_height)), exclude_0 = TRUE, weight = TRUE)$cor
corr_height[is.na(corr_height)] <- 0

corr_order <- similarity_reorderbyclass(corr_height, sample_class[, "disease", drop = FALSE], transform = "sub_1")

disease_legend <- generate_group_colors(2)
names(disease_legend) <- c("cancer", "normal")
row_data <- sample_class[, "disease", drop = FALSE]
row_annotation <- list(disease = disease_legend)

library(viridis)
library(circlize)
colormap <- colorRamp2(seq(0.2, .5, length.out = 20), viridis::viridis(20))

visqc_heatmap(corr_height, colormap, "Weighted Correlation", row_color_data = row_data,
              row_color_list = row_annotation, col_color_data = row_data,
              col_color_list = row_annotation, row_order = corr_order$indices,
              column_order = corr_order$indices)
```

```{r save_josh, eval = FALSE}
library(Cairo)
CairoPNG(filename = "correlation_tissue.png", width = 4800, height = 4800, pointsize = 2, res = 300)
visqc_heatmap(corr_height, colormap, "Weighted Correlation", row_color_data = row_data,
              row_color_list = row_annotation, col_color_data = row_data,
              col_color_list = row_annotation, row_order = corr_order$indices,
              column_order = corr_order$indices)
dev.off()
```

```{r random_forest, eval = FALSE}
library(randomForest)
rf_model <- randomForest(x = t(peak_height), y = as.factor(sample_class$disease), proximity = TRUE)

rf_model

rf_sep <- stats::cmdscale(1 - rf_model$proximity, k = 2, eig = TRUE) # two components, using eigenvalue based 
# data.frames are nicer to work with, but just need the points from cmdscale
rf_sep <- as.data.frame(rf_sep$points)
names(rf_sep) <- c("dim1", "dim2")

# add your class information so can see how classes behave relative to one another using coloring (or shape, etc)
rf_sep$class <- sample_class$disease

library(cowplot)
p <- ggplot(rf_sep, aes(x = dim1, y = dim2, color = class)) + geom_point(size = 3) + ggtitle("Random Forest Proximity")

ggsave("josh_proximity.svg", plot = p, height = 8, width = 8)
```
