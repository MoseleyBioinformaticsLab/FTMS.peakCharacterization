```{r setup}
library(SIRM.FTMS.peakCharacterization)
```

```{r load_data}
zip_files <- dir("~/data/cesb_data/zip_files/lung_matched_tissue-X2017.07.20.14.18.10", pattern = "zip", full.names = TRUE)
zip_data <- zip_ms(zip_files[1], load_raw = TRUE, load_peak_list = FALSE)
load(file.path(zip_data$temp_directory, "peak_finder.rds"))
zip_data$cleanup()
rm(zip_data)
```

```{r round1_correspondence}
mspl <- peak_finder$multi_scan_peaklist
n_scan_peaks <- 3
corr_1 <- MasterPeakList$new(mspl, multiplier = 1, rmsd_min_scans = n_scan_peaks)
```

```{r round2_correspondence}
corr_1$calculate_sd_model()

corr_2 <- MasterPeakList$new(mspl, multiplier = 3, rmsd_min_scans = n_scan_peaks, sd_model = corr_1$sd_model)
```

Now, we do correction on the mspl object!

```{r correct_offsets}
corrected_data <- default_correct_offset_function(corr_2, mspl)
```

And get out the original data in the models to evaluate the spread!

```{r all_models}
corr2_offsets_data <- purrr::map_df(corrected_data$models, loess_to_df)
ggplot(dplyr::filter(corr2_offsets_data, which %in% "original"), aes(x = x, y = y)) + geom_point()
```

And do the correspondence again!

```{r round3_correspondence}
corr_2$calculate_sd_model()
corr_3 <- MasterPeakList$new(corrected_data$multi_scan_peaklist, multiplier = 3, rmsd_min_scans = n_scan_peaks, sd_model = corr_2$sd_model)
```

And do another round of correction!

```{r correct_offsets2}
corrected_data_2 <- default_correct_offset_function(corr_3, corrected_data$multi_scan_peaklist)
```

```{r offset_models2}
corr3_offsets_data <- purrr::map_df(corrected_data_2$models, loess_to_df)
ggplot(dplyr::filter(corr3_offsets_data, which %in% "original"), aes(x = x, y = y)) + geom_point()
```

Compare the two rounds!

```{r}
corr2_offsets_data$round <- "1"
corr3_offsets_data$round <- "2"
compare_offsets <- rbind(corr2_offsets_data, corr3_offsets_data)
ggplot(dplyr::filter(compare_offsets, which %in% "original"), aes(x = y, fill = round)) + geom_density(alpha = 0.5)
ggplot(dplyr::filter(compare_offsets, which %in% "original"), aes(x = x, y = y, color = round)) + geom_point(alpha = 0.5)
```

Do it again!

```{r round4_correspondence}
corr_3$calculate_sd_model()
corr_4 <- MasterPeakList$new(corrected_data_2$multi_scan_peaklist, multiplier = 3, rmsd_min_scans = n_scan_peaks, sd_model = corr_3$sd_model)
```

```{r}
corrected_data_3 <- default_correct_offset_function(corr_4, corrected_data_2$multi_scan_peaklist)
corr_4_offsets_data <- purrr::map_df(corrected_data_3$models, loess_to_df)
corr_4_offsets_data$round <- "3"
```

```{r}
compare_offsets <- rbind(compare_offsets, corr_4_offsets_data)
ggplot(dplyr::filter(compare_offsets, which %in% "original"), aes(x = x, y = y, color = round)) + geom_point(alpha = 0.5)
```

Lets also double check that the correction should be working correctly. We'll cheat
a little bit by creating a MultiScanPeakList object from the corresponded peaks, because
then we can compare the offsets in the original and the corrected.

```{r check_offset_correction}
use_list <- data.frame(ObservedMZ = corr_2$scan_mz[,1])
tmp_mspl <- mspl$clone(deep = TRUE)

tmp_mspl$peak_list_by_scans[[3]]$peak_list <- use_list

tmp_corrected <- default_correct_offset_function(corr_2, tmp_mspl)

new_list <- tmp_corrected$multi_scan_peaklist$peak_list_by_scans[[3]]$peak_list

plot_data <- data.frame(original = use_list$ObservedMZ, corrected = new_list$ObservedMZ,
                        diff = use_list$ObservedMZ - new_list$ObservedMZ)
ggplot(plot_data, aes(x = original, y = diff)) + geom_point()
```

And we can see that compared to the original set of data, the new one has been corrected.

Yay! It looks like everything works!
