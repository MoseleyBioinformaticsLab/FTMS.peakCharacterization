#' read SMIRFE assignments
#'
#' Given a SMIRFE JSON output file, read it in, along with other useful
#' information.
#'
#' @param smirfe_assignment the set of assignment results
#' @param .pb a progress bar object
#'
#' @return list of tic, assignments, sample
#' @export
#'
read_smirfe_assignment <- function(smirfe_assignment, .pb = NULL){
  if (!is.null(.pb)) {
    knitrProgressBar::update_progress(.pb)
  }
  tmp_list <- jsonlite::fromJSON(smirfe_assignment, simplifyVector = FALSE)
  sample <- gsub(".json.output", "", basename(smirfe_assignment))
  list(tic = tmp_list$TotalIntensity$Value,
       assignments = get_assigned_peak_info(tmp_list$Peaks),
       sample = sample)
}

#' choose a single peak
#'
#' Need to choose a single peak to associate with each IMF. This tries to make
#' a choice either by assignment type, IMF E value, or M/Z difference, in that
#' order.
#'
#' @param peak_frame the data.frame with the IMF information
#'
#' @export
#' @return data.frame with only a single peak
#'
choose_peak <- function(peak_frame){
  primary_frame <- peak_frame[peak_frame$Type %in% "Primary", ] # in case it is due to having secondary assignments
  if (nrow(primary_frame) > 0) {
    uniq_frame <- primary_frame[!duplicated(primary_frame[, c("peak_id", "IMF")]), ]
  } else {
    uniq_frame <- peak_frame[!duplicated(peak_frame[, c("peak_id", "IMF")]), ]
    if (all(is.na(uniq_frame$IMF.E.Value))) {
      uniq_frame$IMF.E.Value <- 1
    }
  }

  if (length(uniq_frame$peak_id) == 1) {
    peak_frame <- peak_frame[peak_frame$peak_id %in% uniq_frame$peak_id, ]
  } else if (sum(uniq_frame$IMF.E.Value == max(uniq_frame$IMF.E.Value)) > 1) {
    mz_diff <- abs(uniq_frame$ObservedMZ.Mean - uniq_frame$Assigned.M.Z)
    peak_frame <- peak_frame[peak_frame$peak_id %in% uniq_frame$peak_id[which.min(mz_diff)], ]
  } else {
    peak_frame <- peak_frame[peak_frame$peak_id %in% uniq_frame$peak_id[which.max(uniq_frame$IMF.E.Value)], ]
  }
  peak_frame
}

count_peaks <- function(x){
  length(unique(x$peak_id))
}

#' single peaks
#'
#' given a data.frame of peak assignments, go through and choose a single peak
#' where needed. Trying to avoid running \code{choose_peak} on every single IMF.
#'
#' @param peak_assignments data.frame of peak assignments
#'
#' @return list of IMFs, each with a single peak
#' @export
one_peak_from_imfs <- function(peak_assignments){
  split_imfs <- split(peak_assignments, peak_assignments$IMF)
  n_peak <- purrr::map_dbl(split_imfs, count_peaks)

  single_peaks <- split_imfs[n_peak == 1]
  other_peaks <- purrr::map(split_imfs[n_peak > 1], choose_peak)

  all_peaks <- c(single_peaks, other_peaks)
  all_peaks
}

#' extract peaks
#'
#' To be computably useful, the peak information for each IMF needs to be in a
#' matrix type format. This takes a list of peak-IMF data.frames, and generates
#' a list of matrices to hold the data, where the matrix has IMF rows and sample
#' columns.
#'
#' @param assignment_list list of assignments, one for each sample, generated by \code{read_smirfe_assignment}
#' @param .pb a progress bar object from either dplyr or knitrProgressBar
#'
#' @return list with height, emf, peak, and type, and emf_imf list
#' @export
#'
extract_peaks <- function(assignment_list, .pb = NULL){
  get_imfs <- function(x){x$assignments$IMF}
  get_tic <- function(x){x$tic}
  get_sample <- function(x){x$sample}
  names(assignment_list) <- purrr::map_chr(assignment_list, get_sample)

  all_imfs <- purrr::map(assignment_list, get_imfs)
  all_imfs <- unique(unlist(all_imfs))
  imf_index <- data.frame(IMF = all_imfs, stringsAsFactors = FALSE)

  height_matrix <- matrix(NA, nrow = nrow(imf_index), ncol = length(assignment_list))
  emf_matrix <- matrix(list(), nrow = nrow(imf_index), ncol = length(assignment_list))
  peak_matrix <- matrix(NA, nrow = nrow(imf_index), ncol = length(assignment_list))
  type_matrix <- matrix("NA", nrow = nrow(imf_index), ncol = length(assignment_list))
  emf_imf_mappings <- vector(mode = "list", length = length(assignment_list))
  names(emf_imf_mappings) <- names(assignment_list)

  rownames(height_matrix) <- rownames(emf_matrix) <- rownames(peak_matrix) <- rownames(type_matrix) <- all_imfs
  colnames(height_matrix) <- colnames(emf_matrix) <- colnames(peak_matrix) <- colnames(type_matrix) <- names(assignment_list)

  for (isample in names(assignment_list)) {
    if (!is.null(.pb)) {
      knitrProgressBar::update_progress(.pb)
    }

    imfs <- one_peak_from_imfs(assignment_list[[isample]]$assignments)

    for (iimf in seq_along(imfs)) {
      #print(iimf)
      use_imf <- imfs[[iimf]]
      height_matrix[use_imf$IMF[1], isample] <- use_imf$Height.Mean[1]
      emf_matrix[use_imf$IMF[1], isample][[1]] <- use_imf$EMF
      peak_matrix[use_imf$IMF[1], isample] <- use_imf$peak_id[1]
      type_matrix[use_imf$IMF[1], isample] <- use_imf$Type[1]
    }

    joined_imfs <- purrr::map_df(imfs, function(x){x})
    emf_imf_mappings[[isample]] <- split(joined_imfs$IMF, joined_imfs$EMF)
  }
  list(height = height_matrix,
       emf = emf_matrix,
       peaks = peak_matrix,
       type = type_matrix,
       tic = purrr::map_dbl(assignment_list, get_tic),
       samples = names(assignment_list),
       emf_imf = emf_imf_mappings)
}


unique_nona <- function(value){unique(value[!is.na(value)])}

test_na <- function(in_vector, n = 1){
  length(unique_nona(in_vector)) <= n
}

test_na_matrix <- function(in_matrix){
  unique_na <- purrr::map_lgl(seq(1, ncol(in_matrix)), function(icol){
    test_na(in_matrix[, icol])
  })
  all(unique_na)
}

remove_na_cols <- function(in_matrix){
  not_na <- purrr::map_lgl(seq(1, ncol(in_matrix)), function(icol){
    !all(is.na(in_matrix[, icol]))
  })
  in_matrix[, not_na, drop = FALSE]
}

clean_imfpeak_matrix <- function(imf_2_peaks, n = 1){
  # find any sample that actually has more than one peak in it
  unique_na <- purrr::map_lgl(seq(1, ncol(imf_2_peaks)), function(icol){
    test_na(imf_2_peaks[, icol], n = n)
  })
  # remove it
  imf_2_peaks <- imf_2_peaks[, unique_na, drop = FALSE]

  # after removing a sample with multiple peaks to our IMFs, then make sure we
  # haven't made any of our rows all NA, not likely, but could happen
  na_rows <- purrr::map_lgl(seq(1, nrow(imf_2_peaks)), function(irow){
    all(is.na(imf_2_peaks[irow, ]))
  })

  imf_2_peaks <- imf_2_peaks[!na_rows, , drop = FALSE]
  imf_2_peaks
}

filter_extracted <- function(keep_imfs, extracted_data){
  filter_vars <- c("height", "peaks", "emf", "type")
  extracted_data[filter_vars] <- purrr::map(extracted_data[filter_vars], function(in_var){
    in_var[keep_imfs, ]
  })
  extracted_data
}

#' find duplicate peaks
#'
#' @param extracted_data generated by \code{extract_peaks}
#' @param .pb a progress object, should be equal to the number of samples used.
#'
#' @export
#' @return deduplicated list
find_duplicate_peaks <- function(extracted_data, .pb = NULL){
  split_imfs <- purrr::map(seq(1, ncol(extracted_data$peaks)), function(in_sample){
    split(rownames(extracted_data$peaks), extracted_data$peaks[, in_sample])
  })
  names(split_imfs) <- colnames(extracted_data$peaks)

  all_imfs <- data.frame(imf = rownames(extracted_data$height), grabbed = FALSE,
                         stringsAsFactors = FALSE)
  all_imfs$others <- vector("list", length = nrow(all_imfs))

  for (isplit in split_imfs) {
    if (!is.null(.pb)) {
      knitrProgressBar::update_progress(.pb)
    }
    isplit_diffs <- purrr::map(isplit, function(x){
      base::setdiff(x, all_imfs$imf[all_imfs$grabbed])
    })
    isplit_null <- purrr::map_lgl(isplit_diffs, function(x){length(x) == 0})
    isplit_diffs <- isplit_diffs[!isplit_null]

    for (ipeak in names(isplit_diffs)) {
      all_peaks <- extracted_data$peaks[isplit_diffs[[ipeak]], , drop = FALSE]
      all_peaks <- remove_na_cols(all_peaks)

      curr_imfs <- purrr::map(colnames(all_peaks), function(isample){
        use_peak <- as.character(unique_nona(all_peaks[, isample]))
        split_imfs[[isample]][use_peak]
      })
      curr_imfs <- unique(unlist(curr_imfs))

      imf_2_peaks <- extracted_data$peaks[curr_imfs, colnames(all_peaks), drop = FALSE]
      imf_2_peaks <- clean_imfpeak_matrix(imf_2_peaks, n = 2)

      together_imfs <- rownames(imf_2_peaks)

      all_imfs[all_imfs$imf %in% together_imfs, "grabbed"] <- TRUE
      all_imfs[all_imfs$imf %in% together_imfs[1], "others"][[1]] <- list(together_imfs)
    }
  }
  all_imfs <- all_imfs[all_imfs$grabbed, ]
  null_imfs <- purrr::map_lgl(all_imfs$others, is.null)
  all_imfs <- all_imfs[!null_imfs, ]

  extracted_data2 <- filter_extracted(all_imfs$imf, extracted_data)
  extracted_data2$imf_2_imf <- all_imfs$others
  extracted_data2
}
