---
title: "Transient Level Peak Picking"
author: "Robert M Flight"
date: "`r Sys.time()`"
commit: "`r substr(git2r::branch_target(git2r::head(git2r::repository())), 1, 8)`"
output: 
  pdf_document: 
    toc: yes
---

# Purpose

Working out how to do transient level peak picking.

# Data

Lets load up some data working at the transient level.

```{r load_transient_level}
library(notifier)

library(xcms)
library(dplyr)
library(ggplot2)
library(SIRM.FTMS.peakPickingMethods)
library(ggplot2)
options(digits = 16)

mz_file <- "/home/rmflight/Projects/work/CESB/ftms.QC/mzML_exported/92Cpos.mzML"
rawdata <- xcms::xcmsRaw(mz_file, profstep = 0)
scan_level <- as.data.frame(xcms::getScan(rawdata, 1))

scan_test <- filter(scan_level, (mz >= 150.026) & (mz <= 150.0271))
mz_data <- scan_test
```

So, our basic idea is to start very simply, and then escalate for peaks where the
simple things don't work. This requires us to set some simple metrics that tell
us whether or not a peak was likely picked correctly.

The steps I am imagining are:

* Classify as a flat or pointed peak
  * This is important because it changes how we handle looking at the center from
  the model.
* Fit a parabolic model to log-transformed values
* Flat peaks: check that center intensity is above max point, and between the flat points
* Pointed peaks: check that center intensity is within a weighted value of max, and near to it
* If checks fail, then:
* Try weighted parabolic fit, where weights are derived from point intensities
* Check again
* Try weighted **cauchy** fit
* Record generated parameters, and whether sanity checks pass for a peak.

## Peak Correspondence

We've got a bunch of methods for summarizing the peaks down to a single location
and intensity, now we need to figure out which one is best and most consistent.
To help with this, we need to match up the peaks across scans and get peak
correspondence. Lets play with that

```{r get_peaks_from_multiple_scans, cache=TRUE, cache.lazy=FALSE}
multi_scans <- vector(mode = "list", length = 36)

for (in_scan in seq(1, 36)) {
  print(in_scan)
  multi_scans[[in_scan]] <- ScanMS$new(as.data.frame(xcms::getScan(rawdata, in_scan)))
}

notify(msg = "multiscans done")
```


```{r extract_peak_lists}
peak_lists <- lapply(multi_scans, function(x){
  x$get_peak_info(calc_type = "lm_weighted")
})
```

```{r correspondence}
count_notna <- function(in_matrix){
  apply(in_matrix, 1, function(x){sum(!is.na(x))})
}

create_master <- function(mz_matrix){
  rowMeans(mz_matrix, na.rm = TRUE)
}

peaks_n <- vapply(peak_lists, nrow, numeric(1))

init_multiplier <- 10

scan_mz  <- scan_intensity <- scan_peak <- matrix(NA, nrow = peaks_n * init_multiplier, ncol = length(peak_lists))

n_in1 <- length(peak_lists[[1]]$ObservedMZ)

# initialize the master list
scan_mz[1:n_in1, 1] <- peak_lists[[1]]$ObservedMZ
scan_intensity[1:n_in1, 1] <- peak_lists[[1]]$Intensity
scan_peak[1:n_in1, 1] <- peak_lists[[1]]$peak

master_peaks <- create_master(scan_mz)

diff_cut <- 4e-5

new_peaks <- rep(0, length(peak_lists))
new_peaks[1] <- n_in1

#out_scan <- 3
out_scan <- length(peak_lists)

for (iscan in seq(2, out_scan)) {
  #print(iscan)
  tmp_scan <- peak_lists[[iscan]]
  n_scan_peak <- nrow(tmp_scan)
  peak_new <- rep(FALSE, n_scan_peak)
  for (ipeak in seq(1, n_scan_peak)) {
    diff_master <- abs(tmp_scan[ipeak, "ObservedMZ"] - master_peaks)
    
    if (min(diff_master, na.rm = TRUE) <= diff_cut) {
      which_min <- which.min(diff_master)
      scan_mz[which_min, iscan] <- tmp_scan[ipeak, "ObservedMZ"]
      scan_intensity[which_min, iscan] <- tmp_scan[ipeak, "Intensity"]
      scan_peak[which_min, iscan] <- tmp_scan[ipeak, "peak"]
    } else {
      peak_new[ipeak] <- TRUE
    }
  }
  
  n_new <- sum(peak_new)
  new_peaks[iscan] <- n_new
  if (n_new > 0) {
    fit_new <- (sum(is.nan(master_peaks)) - n_new) >= 0
    
    if (!fit_new) {
      n_na <- n_new + 2000
      #master_peaks <- c(master_peaks, rep(NA, n_na))
      na_matrix <- matrix(NA, nrow = n_na, ncol = length(peak_lists))
      scan_mz <- rbind(scan_mz, na_matrix)
      scan_intensity <- rbind(scan_intensity, na_matrix)
      scan_peak <- rbind(scan_peak, na_matrix)
    } 
    master_peaks <- create_master(scan_mz)
    which_na <- min(which(is.nan(master_peaks)))
    new_loc <- seq(which_na, which_na + n_new - 1)
    
    scan_mz[new_loc, iscan] <- tmp_scan[peak_new, "ObservedMZ"]
    scan_intensity[new_loc, iscan] <- tmp_scan[peak_new, "Intensity"]
    scan_peak[new_loc, iscan] <- tmp_scan[peak_new, "peak"]
    master_peaks <- create_master(scan_mz)
    
    new_order <- order(master_peaks, decreasing = FALSE)
    scan_mz <- scan_mz[new_order, ]
    scan_intensity <- scan_intensity[new_order, ]
    scan_peak <- scan_peak[new_order, ]
    master_peaks <- master_peaks[new_order]
  }
  
}

notify(msg = "correspondence done")

n_notna <- count_notna(scan_mz)
hist(n_notna, 100)
```


# Workflow for Transient-Level Peak Finding

* Transform to log-space
* Find peaks using `pracma::findpeaks`
* For each peak:
    * Check that non-zero points have significant area
    * Fit a parabolic model to non-zero points
    * Find the peak center and intensity based on the model
    * Integrate parabola and sides to get peak area


