---
title: "Transient Level Peak Picking"
author: "Robert M Flight"
date: "`r Sys.time()`"
commit: "`r substr(git2r::branch_target(git2r::head(git2r::repository())), 1, 8)`"
output: 
  pdf_document: 
    toc: yes
---

# Purpose

Working out how to do transient level peak picking.

# Data

Lets load up some data working at the transient level.

```{r load_transient_level}
library(xcms)
library(dplyr)
library(ggplot2)
library(SIRM.FTMS.peakPickingMethods)
library(ggplot2)
options(digits = 16)

mz_file <- "/home/rmflight/Projects/work/CESB/ftms.QC/mzML_exported/92Cpos.mzML"
rawdata <- xcms::xcmsRaw(mz_file, profstep = 0)
scan_level <- as.data.frame(xcms::getScan(rawdata, 1))

scan_test <- filter(scan_level, (mz >= 150.026) & (mz <= 150.0271))
mz_data <- scan_test
```

So, our basic idea is to start very simply, and then escalate for peaks where the
simple things don't work. This requires us to set some simple metrics that tell
us whether or not a peak was likely picked correctly.

The steps I am imagining are:

* Classify as a flat or pointed peak
  * This is important because it changes how we handle looking at the center from
  the model.
* Fit a parabolic model to log-transformed values
* Flat peaks: check that center intensity is above max point, and between the flat points
* Pointed peaks: check that center intensity is within a weighted value of max, and near to it
* If checks fail, then:
* Try weighted parabolic fit, where weights are derived from point intensities
* Check again
* Try weighted **cauchy** fit
* Record generated parameters, and whether sanity checks pass for a peak.

## Classification as flat or pointed

To classify the peaks as flat or pointed, lets try examining the relative
differences between the two highest points in a peak.

```{r classify_peak}
mz_data <- scan_level
min_points <- 5
n_peak <- Inf
peak_locations <- pracma::findpeaks(mz_data$intensity, nups = floor(min_points/2),
                                      ndowns = floor(min_points/2))
peak_locations <- matrix(peak_locations, ncol = 4, byrow = FALSE)
n_peak <- nrow(peak_locations)

mz_data$log_int <- SIRM.FTMS.peakPickingMethods:::log_with_min(mz_data$intensity)

flat_cut <- 0.98

# For each peak identified, classify it as flat or pointed, and then define
# how high the max intensity from any model should be, as well as the limits
# where the center point from the model should be.
all_peak_diffs <- lapply(seq(1, n_peak), function(in_peak){
  peak_loc <- seq(peak_locations[in_peak, 3], peak_locations[in_peak, 4])
  peak_data <- mz_data[peak_loc, ]
  peak_loc2 <- seq(1, nrow(peak_data))
  peak_max_loc <- which.max(peak_data$intensity[peak_loc2])
  peak_loc_nomax <- peak_loc2[peak_loc2 != peak_max_loc]
  peak_2nd_loc <- peak_loc_nomax[which.max(peak_data$intensity[peak_loc_nomax])]
  peak_ratio <- peak_data$intensity[peak_2nd_loc] / peak_data$intensity[peak_max_loc]
  if (peak_ratio >= flat_cut) {
    use_locs <- sort(c(peak_max_loc, peak_2nd_loc))
    max_data <- list(peak_points = peak_loc,
                           max_intensity = peak_data$intensity[peak_max_loc],
                           min_loc = peak_data$mz[use_locs[1]], max_loc = peak_data$mz[use_locs[2]],
                           type = "flat")
  } else {
    
    either_side_diff <- abs(peak_data$mz[peak_max_loc + 1] - peak_data$mz[peak_max_loc - 1]) / 2
    max_data <- list(peak_points = peak_loc,
                           max_intensity = peak_data$intensity[peak_max_loc],
                           min_loc = peak_data$mz[peak_max_loc] - either_side_diff,
                           max_loc = peak_data$mz[peak_max_loc] + either_side_diff,
                           type = "point", stringsAsFactors = FALSE)
  }
  max_data
})

for (ipeak in seq_len(length(all_peak_diffs))) {
  peak_diff <- all_peak_diffs[[ipeak]]
  peak_loc <- peak_diff$peak_points
  tmp <- peak_info(mz_data[peak_loc, ], min_points = min_points)
}

# playing with regression
in_peak <- all_peak_diffs[[1]]
x <- mz_data[in_peak$peak_points, "mz"]
y <- mz_data[in_peak$peak_points, "log_int"]
x_center <- x - mean(x)
x_c2 <- x_center ^ 2

X <- matrix(c(rep(1, length(x)), x_center, x_c2), nrow = length(x), ncol = 3, byrow = FALSE)

in_data <- data.frame(y = y, x = x_center, x2 = x_c2)

test_model <- lm(y ~ x + x2, data = in_data)

w <- mz_data[in_peak$peak_points, "intensity"] / max(mz_data[in_peak$peak_points, "intensity"]) / 2

test_model2 <- lm(y ~ x + x2, data = in_data, weights = w)
p1 <- data.frame(y = predict(test_model), x = x_center, type = "model1")
p2 <- data.frame(y = predict(test_model2), x = x_center, type = "model2")

test_pt <- seq(from = x_center[1], to = x_center[length(x_center)], length.out = 10000)
out_data <- data.frame(x = test_pt, x2 = test_pt^2)

p3 <- data.frame(y = predict(test_model2, newdata = out_data), x = out_data$x)

ggplot(in_data, aes(x = x, y = exp(y))) + geom_point() + geom_line() + geom_point(data = p1, color = "red") + geom_point(data = p2, color = "blue") + ylim(0, 5e4) + geom_point(data = p3, color = "green")

p3[which.max(p3$y), ]

out_lmwfit <- lm.wfit(X, y, w)
all.equal(out_lmwfit$residuals, test_model2$residuals)

# peak_info <- lapply(all_peak_diffs, function(in_peak) {
#   peak_data <- mz_data[in_peak$peak_points, ]
#   peak_model1 <- SIRM.FTMS.peakPickingMethods:::parabolic_fit(peak_data$mz, peak_data$log_int)
#   peak_center_model1 <- model_peak_center_intensity(peak_data$mz, peak_model1)
#   is_middle <- (peak_center_model1["ObservedMZ"] >= in_peak$min_loc) & (peak_center_model1["ObservedMZ"] <= in_peak$max_loc)
#   is_above <- exp(peak_center_model1["Intensity"]) >= in_peak$max_intensity
#   
#   peak_weights <- peak_data$intensity / max(peak_data$intensity)
#   peak_model2 <- SIRM.FTMS.peakPickingMethods:::parabolic_fit(peak_data$mz*peak_weights, peak_data$log_int*peak_weights)
#   peak_center_model2 <- model_peak_center_intensity(peak_data$mz*peak_weights, peak_model2)
# })


```

```{r plot_two_measures}
peak_type_info <- data.frame(diff_ratio = all_peak_diffs, center_dist = center_dist_from_max, which = seq(1, length(all_peak_diffs)))
ggplot(peak_type_info, aes(x = center_dist, y = diff_ratio)) + geom_point(alpha = 0.5) +
  geom_point(data = peak_type_info[1,], color = "red")
```


```{r try_cauchy_function}
cauchy_estimate <- function(x, params){
  xnot <- params[1]
  g <- params[2]
  max_real <- params[3]
  denom <- pi * g * (1 + ((x - xnot) / g)^2)
  new_y <- 1 / denom
  scale_factor <- max_real / max(new_y)
  new_y * scale_factor
}

test_params <- c(20, 2, 10)

use_x <- seq(1, 40, length.out = 100)
pure_y <- cauchy_estimate(use_x, test_params)
error_y <- fakeDataWithError::add_uniform_noise(1, pure_y, 0.1)

test_data <- data.frame(mz = use_x, intensity = error_y)

test_fit <- nls(intensity ~ cauchy_estimate(mz, c(xnot, g, scale)), data = test_data, start = c(xnot = 18, g = 1, scale = 15))
test_data$pred <- test_fit$m$predict()
ggplot(test_data, aes(x = mz, y = intensity)) + geom_point() + geom_line() + geom_point(aes(x = mz, y = pred), color = "red")

test_mz <- mz_data[all_peak_diffs[[1]]$peak_points, ]
x.0 <- median(test_mz[test_mz$intensity >= 400, "mz"])
gamma.0 <- 1e-4

out_cauchy <- cauchy_estimate(test_mz$mz, max(test_mz$intensity), c(x.0, gamma.0, max(test_mz$intensity)))

test_plot <- test_mz[, c("mz", "intensity")]
test_plot$type <- "orig"
test_plot <- rbind(test_plot, data.frame(mz = test_mz$mz, intensity = out_cauchy, type = "cauchy"))

ggplot(test_plot, aes(x = mz, y = intensity, color = type)) + geom_line() + geom_point()

test_mz$max_value <- max(test_mz$intensity)
fit_weight <- test_mz$intensity / test_mz$max_value
fit <- nls(intensity ~ cauchy_estimate(mz, max_value, c(xnot, g)), data = test_mz, start = c(xnot = x.0, g = gamma.0), 
           nls.control(minFactor = 1/1e14, warnOnly = TRUE, maxiter = 200), weights = fit_weight)

fit_cauchy <- fit$m$predict()

fit_cauchy <- data.frame(mz = test_mz$mz, intensity = fit_cauchy, type = "fit")
ggplot(test_plot, aes(x = mz, y = intensity, color = type)) + geom_point() + geom_line() +
  geom_point(data = fit_cauchy) + geom_line(data = fit_cauchy)
```


# Workflow for Transient-Level Peak Finding

* Transform to log-space
* Find peaks using `pracma::findpeaks`
* For each peak:
    * Check that non-zero points have significant area
    * Fit a parabolic model to non-zero points
    * Find the peak center and intensity based on the model
    * Integrate parabola and sides to get peak area

```{r peak_pick_one_transient}
scan_peaks <- find_peaks(scan_level)
```

# Check Parabolic vs Basic differences

We will look for examples where there is a big difference in the `model` center
and the `basic` center, as that may imply there is something odd going on.

```{r model_vs_basic}
basic_peaks <- dplyr::filter(scan_peaks, type == "basic")
area_peaks <- dplyr::filter(scan_peaks, type == "area")
rsq_98_peaks <- dplyr::filter(scan_peaks, type == "rsq_98")
rsq_95_peaks <- dplyr::filter(scan_peaks, type == "rsq_95")

area_diff <- abs(area_peaks$ObservedMZ - basic_peaks$ObservedMZ)
rsq_98_diff <- abs(rsq_98_peaks$ObservedMZ - basic_peaks$ObservedMZ)
rsq_95_diff <- abs(rsq_95_peaks$ObservedMZ - basic_peaks$ObservedMZ)

sum(area_diff <= 5e-4)

sum(is.na(rsq_98_diff))
sum(rsq_98_diff[!is.na(rsq_98_diff)] <= 5e-4)

sum(is.na(rsq_95_diff))
sum(rsq_95_diff[!is.na(rsq_95_diff)] <= 5e-4)

```

```{r plot_all_peaks}
library(plotly)
p <- ggplot(scan_level, aes(x = mz, y = intensity)) + geom_line()
q <- p + geom_point(data = scan_peaks, aes(x = ObservedMZ, y = Intensity, color = type))
ggplotly(q)
```

```{r check_2556}
use_peak <- 2556

mz_data <- dplyr::filter(scan_level, (mz >= 1174.77) & (mz <= 1174.8))
min_points <- 5
n_peak <- Inf

peak_locations <- pracma::findpeaks(mz_data$intensity, nups = floor(min_points/2),
                                      ndowns = floor(min_points/2))
peak_locations <- matrix(peak_locations, ncol = 4, byrow = FALSE)
mz_data$log_int <- metabolomicsUtilities::log_with_min(mz_data$intensity)

in_peak <- 1
peak_loc <- seq(peak_locations[in_peak, 3], peak_locations[in_peak, 4])

possible_peak <- mz_data[peak_loc, ]



mz_data_plot1 <- mz_data
mz_data_plot1$type <- "org"
mz_data_plot1 <- rbind(mz_data_plot1, mz_data_plot1[peak_loc, ])
mz_data_plot1[23:34, "type"] <- "pracma"

ggplot(mz_data_plot1, aes(x = mz, y = intensity, color = type)) + geom_point() + geom_line()
```

OK, this looks good. Lets see what went into the model.

```{r}
possible_peak <- mz_data[peak_loc, ]
min_area <- 0.1

area_peak <- SIRM.FTMS.peakPickingMethods:::test_peak_area(possible_peak[, c("mz", "intensity")], min_points = min_points - 2)
area_points <- SIRM.FTMS.peakPickingMethods:::choose_peak_points_area(area_peak, min_area)


```

# Things to Do

* For area based peak method, can we exclude points based on their slope to
the next point in the peak? Points to exclude would have low slopes at
the ends.
* Alternatively, instead of R^2 on the parabolic model, could we use residuals
of the points to the model to exclude them?
* The way we should be judging the quality of each method is by examining
the variance in the location, intensity, and area of a given peak across
multiple transients.
