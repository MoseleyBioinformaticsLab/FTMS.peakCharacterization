---
title: "Transient Level Peak Picking"
author: "Robert M Flight"
date: "`r Sys.time()`"
commit: "`r substr(git2r::branch_target(git2r::head(git2r::repository())), 1, 8)`"
output: 
  pdf_document: 
    toc: yes
---

# Purpose

Working out how to do transient level peak picking.

# Data

Lets load up some data working at the transient level.

```{r load_transient_level}
library(xcms)
library(dplyr)
library(ggplot2)

mz_file <- "/home/rmflight/Projects/work/CESB/ftms.QC/mzML_exported/92Cpos.mzML"
rawdata <- xcms::xcmsRaw(mz_file, profstep = 0)
scan_level <- as.data.frame(xcms::getScan(rawdata, 1))

scan_test <- filter(scan_level, (mz >= 150.026) & (mz <= 150.0271))
mz_data <- scan_test
```

# Define how to transform the data

To fit the parabolic, the peaks first have to be transformed to log-space.

```{r log_transform}
library(metabolomicsUtilities)
log_peaks <- function(mz_data, intensity = "intensity"){
  #out_command <- paste0("metabolomicsUtilities::log_with_min(", intensity, ")")
  log_values <- metabolomicsUtilities::log_with_min(mz_data[, intensity])
  mz_data$log_int <- log_values
  mz_data
}
mz_data <- log_peaks(mz_data)
```

# Find Peaks using PRACMA findpeaks

```{r run_pracma_findpeaks}
initial_peaks <- pracma::findpeaks(mz_data$log_int)
```


# Test Vector for Parabolic Fit

From both ends of the vector of points, we will evaluate the fit to a parabola,
and keep the set of points that fit above a particular cutoff and contain the
most points of the peak.

```{r test_fit}
r_squared <- function(x, y){
  x <- x - mean(x)
  x_2 <- poly(x, 2)
  
  (t(y) %*% x_2 %*% t(x_2) %*% y) / (t(y) %*% (diag(length(y)) - 
                                                 1 / length(y)) %*% y)
}

mz_peak <- mz_data[seq(initial_peaks[1, 3], initial_peaks[1, 4]), c("mz", "log_int")]
pracma_peak_index <- seq(initial_peaks[1, 3], initial_peaks[1, 4])

test_peak_points <- function(mz_peak, min_points = 5){
  n_point <- nrow(mz_peak)
  if (n_point >= min_points) {
    test_index <- lapply(seq(1, n_point - min_points), function(start_loc){
      lapply(seq(start_loc + min_points - 1, n_point), function(end_loc){
        c(start_loc, end_loc)
      })
    })
    index_matrix <- matrix(unlist(test_index), ncol = 2, byrow = TRUE)
    
    n_test <- nrow(index_matrix)
    pt_rsq <- t(vapply(seq(1, n_test), function(in_row){
      use_index <- index_matrix[in_row, ]
      c(use_index, use_index[2] - use_index[1] + 1, 
        r_squared(mz_peak[use_index[1]:use_index[2], "mz"], mz_peak[use_index[1]:use_index[2], "log_int"]))
    }, numeric(4)))
  } else {
    pt_rsq <- matrix(NA, nrow = 1, 4)
  }
  pt_rsq
}

mz_rsq <- test_peak_points(mz_peak)

choose_peak_points <- function(rsq_results, min_rsq = 0.98){
  filter_rsq <- rsq_results[rsq_results[,4] >= min_rsq, , drop = FALSE]
  if (nrow(filter_rsq) > 0) {
    out_index <- filter_rsq[which.max(filter_rsq[, 3]), 1:2]
    out_points <- seq(out_index[1], out_index[2])
  } else {
    out_points <- NA
  }
  out_points
}

peak_points <- choose_peak_points(mz_rsq)
peak_index <- pracma_peak_index[peak_points]
```

# Fit the Model

Now that we have a location for the peak that **should** fit the model we want,
lets actually calculate the model.

```{r fit_model}
#' parabolic fit
#' 
#' calculates the coefficients of a parabolic fit (y = x + x^2) of x to y
#'
#' @param x the x-values, independent
#' @param y the y-values, dependent
#'
#' return vector
parabolic_fit <- function(x, y){
  center_x <- x - mean(x)
  x_matrix <- cbind(1, center_x, center_x^2)
  
  as.vector(solve(t(x_matrix) %*% x_matrix, t(x_matrix) %*% y, tol = 1e-18))
}

peak_model <- parabolic_fit(mz_data$mz[peak_index], mz_data$log_int[peak_index])
```

# Find Center of Peak and Intensity

Using the model we created, we can find the center of the peak based on the 
mean of the x-points, and then the intensity of the peak at the center based
on the model.

```{r center_intensity}
model_peak_center_intensity <- function(x, coefficients){
  center_x <- mean(x)
  center_int <- coefficients[1]
  c(ObservedMZ = center_x, Intensity = center_int)
}

peak_center <- model_peak_center_intensity(mz_data$mz[peak_index], peak_model)

basic_peak_center_intensity <- function(mz, intensity){
  n_point <- length(mz)
  seq_point <- seq(1, n_point)
  if ((n_point %% 2) == 0) {
    peak_center <- mean(mz)
    
    peak_intensity <- mean(intensity[floor(mean(seq_point))],
                           intensity[ceiling(mean(seq_point))])
  } else {
    peak_center <- mz[mean(seq_point)]
    peak_intensity <- intensity[mean(seq_point)]
  }
  c(ObservedMZ = peak_center, Intensity = peak_intensity)
}
```


# Peak Area

The peak area we will caculate a couple of different ways.

1. Summing the actual points contained in the peak
2. Integrating the peak area based on the model over the fit points

## Sum Points

```{r sum_points}
raw_sum <- sum(mz_data$intensity[pracma_peak_index])
log_sum <- sum(mz_data$log_int[pracma_peak_index] - mz_data$log_int[pracma_peak_index][1])

area_sum_points <- function(peak_mz, peak_intensity, zero_value = 0){
  mean_diff <- mean(diff(peak_mz))
  c(Area = sum((peak_intensity - zero_value) * mean_diff))
}

area_sum <- area_sum_points(mz_data$mz[pracma_peak_index], mz_data$intensity[pracma_peak_index], 0)
```

## Integrate Over Range

```{r integrate_points}
integrate_model <- function(peak_loc, model_coeff, n_point = 100, log_transform = "log"){
  model_function <- function(model_coeff){
    function(x, log_transform = "log"){
      out_val <- model_coeff[1] + model_coeff[2]*x + model_coeff[3]*(x^2)
      if (log_transform == "log") {
        out_val <- exp(out_val)
      }
      out_val
    }
  }
  
  integrate_function <- model_function(model_coeff)
  
  mn_peak_loc <- peak_loc - mean(peak_loc)
  
  peak_area <- stats::integrate(integrate_function, min(mn_peak_loc), max(mn_peak_loc), log_transform = log_transform)
  c(Area = peak_area$value)
  
}

area_integrate <- integrate_model(mz_data$mz[peak_index], peak_model)
```

## Wrap Up Into Bigger Function

Now we can take all of our smaller functions for each step, and wrap them up
into something that will do all the steps for a given peak.

```{r peak_info}
possible_peak <- mz_data[pracma_peak_index, ]
min_points <- 5
peak_info <- function(possible_peak, min_points = 5){
  if (nrow(possible_peak) >= min_points) {
    rsq_peak <- test_peak_points(possible_peak[, c("mz", "log_int")], min_points = min_points)
    rsq_points <- choose_peak_points(rsq_peak)
    peak_area_basic <- area_sum_points(possible_peak$mz, possible_peak$intensity)
    peak_center_basic <- basic_peak_center_intensity(possible_peak$mz, possible_peak$intensity)
    if (!is.na(rsq_points[1])) {
      peak_model <- parabolic_fit(possible_peak[rsq_points, "mz"], possible_peak[rsq_points, "log_int"])
      peak_center_model <- model_peak_center_intensity(possible_peak$mz[rsq_points], peak_model)
      peak_center_model["Intensity"] <- exp(peak_center_model["Intensity"])
      peak_area_model <- integrate_model(possible_peak$mz[rsq_points], peak_model)
    } else {
      peak_center_model <- c(ObservedMZ = NA, Intensity = NA)
      peak_area_model <- c(Area = NA)
    }
    
  } else {
    peak_area_basic <- c(Area = NA)
    peak_center_basic <- c(ObservedMZ = NA, Intensity = NA)
    peak_center_model <- c(ObservedMZ = NA, Intensity = NA)
    peak_area_model <- c(Area = NA)
  }
  out_peak <- as.data.frame(rbind(c(peak_center_basic, peak_area_basic),
                                  c(peak_center_model, peak_area_model)))
  out_peak$type <- c("basic", "model")
  out_peak
}

peak_stats <- peak_info(mz_data[pracma_peak_index, ], 5)
```

So this gives us the information on a single peak. Now, of course we need to run
it on a lot of peaks.

```{r find_peaks}
find_peaks <- function(mz_data, min_points = 5, n_peak = Inf){
  peak_locations <- pracma::findpeaks(mz_data$intensity, nups = floor(min_points/2),
                                      ndowns = floor(min_points/2))
  peak_locations <- matrix(peak_locations, ncol = 4, byrow = FALSE)
  mz_data$log_int <- metabolomicsUtilities::log_with_min(mz_data$intensity)
  
  if (is.infinite(n_peak)) {
    n_peak <- nrow(peak_locations)
  } else {
    n_peak <- min(c(nrow(peak_locations), n_peak))
  }
  mz_peaks <- lapply(seq(1, n_peak), function(in_peak){
    print(in_peak)
    peak_loc <- seq(peak_locations[in_peak, 3], peak_locations[in_peak, 4])
    peak_stats <- peak_info(mz_data[peak_loc, ], min_points = min_points)
    peak_stats$Peak <- in_peak
    peak_stats
  })
  out_peaks <- do.call(rbind, mz_peaks)
  out_peaks
}

scan_peaks <- find_peaks(scan_level)
```


This gives an error, way way down in `.centered.coeffs`, where it looks like it
is doing the actual regression. Lets see if we can recreate what is going on.

```{r long_peak_picking}
plot_data <- as.data.frame(scan_matrix2)
plot_data$class <- "original"
peak.base <- scan_matrix2
# locate.peaks
num.pts = 5
R2.thresh = 0.90
oneside.min = 1
thresh = -Inf
loc.max <- FTICRMS:::.loc.maxes(peak.base[, 2])
loc.max <- intersect(which(peak.base[, 2] >= thresh), loc.max)
loc.max <- loc.max[loc.max >= oneside.min + 1 & loc.max <= 
            length(peak.base[, 2]) - oneside.min]

plot_max <- plot_data[loc.max, , drop = FALSE]
plot_max$class <- "max"
plot_plot <- rbind(plot_data, plot_max)

x <- loc.max
locs <- x + ((-num.pts + oneside.min + 1):(num.pts - 
                oneside.min - 1))
locs <- locs[locs >= 1 & locs <= dim(peak.base)[1]]

pt_loc <- plot_data[locs, ]
pt_loc$class <- "locate_loc"
plot_plot <- rbind(plot_plot, pt_loc)

# .peak.parab
pts <- peak.base[locs, ]
# which ones went into here
parab_locs <- locs

# which points fit the parabola
Rsq <- sapply(1:(dim(pts)[1] - num.pts + 1), function(x) {
        FTICRMS::.Rsquared(pts[x + (0:(num.pts - 1)), ])
})
locs <- which.max(Rsq) + (0:(num.pts - 1))

rsq_pts <- plot_data[parab_locs[locs], ]
rsq_pts$class <- "rsq"
plot_plot <- rbind(plot_plot, rsq_pts)


rsq_pts$mz2 <- rsq_pts$mz ^ 2
rsq_pts$class <- "org"
rsq_model <- lm(intensity ~ mz + mz2, data = rsq_pts)
rsq_pred <- data.frame(mz = rsq_pts$mz, intensity = predict(rsq_model), mz2 = rsq_pts$mz2, class = "pred")
rsq_plot <- rbind(rsq_pts, rsq_pred)

# .centered.coeffs
M <- pts[locs, ]
Y <- M[, 2]
X <- M[, 1] - mean(M[, 1])
X2 <- X ^ 2

model_frame <- data.frame(Y = Y, X = X, X2 = X2)

m_mod <- lm(Y ~ X + X2, data = model_frame)
p_mod <- predict(m_mod)

x_plot <- data.frame(mz = c(X, X), int = c(Y, p_mod), class = rep(c("org", "pred"), each = length(Y)))
ggplot(x_plot, aes(x = mz, y = exp(int), color = class)) + geom_point() + geom_line()

coeffs <- coefficients(m_mod)
out_val <- c(mean(pts[locs, 1]) - coeffs[2]/2/coeffs[3],
             coeffs[1] - coeffs[2]^2/4/coeffs[3], -1/coeffs[3])
names(out_val) <- c("center", "intensity", "width")

out_val2 <- data.frame(mz = c(out_val["center"],
                              out_val["center"] - out_val["width"],
                              out_val["center"] + out_val["width"]),
                       intensity = c(out_val["intensity"],
                                     0,
                                     0),
                       class = "found")

plot_plot <- rbind(plot_plot, out_val2)

ggplot(plot_plot, aes(x = mz, y = intensity, color = class)) + geom_point() + geom_line()
```

So something seems off with the width. Not sure what exactly. We will generate
two separate sets of functions and see if we can get the FTICRMS code to run 
even on some peaks and pick out some differences.

We will add a `try` in their code to capture the error message and allow it to
keep running, and then replace `solve` with the `lm` call.

## Original

```{r original_functions}
.centered.coeffs <- function (M) 
{
    Y <- M[, 2]
    X <- M[, 1] - mean(M[, 1])
    Xb <- cbind(1, X, X^2)
    as.vector(Matrix::solve(t(Xb) %*% Xb, t(Xb) %*% Y, tol = 1e-18))
}

.peak.parab <- function (pts, num.pts, R2.thresh) 
{
    Rsq <- sapply(1:(dim(pts)[1] - num.pts + 1), function(x) {
        FTICRMS::.Rsquared(pts[x + (0:(num.pts - 1)), ])
    })
    if (max(Rsq) >= R2.thresh) {
        locs <- which.max(Rsq) + (0:(num.pts - 1))
        coeffs <- .centered.coeffs(pts[locs, ])
        return(c(mean(pts[locs, 1]) - coeffs[2]/2/coeffs[3], 
            coeffs[1] - coeffs[2]^2/4/coeffs[3], -1/coeffs[3]))
    }
    else {
        return(rep(0, 3))
    }
}

locate.peaks <- function (peak.base, num.pts = 5, R2.thresh = 0.98, oneside.min = 1, 
    peak.method = c("parabola", "locmaxes"), thresh = -Inf) 
{
    loc.max <- FTICRMS::.loc.maxes(peak.base[, 2])
    loc.max <- intersect(which(peak.base[, 2] >= thresh), loc.max)
    peak.method <- match.arg(peak.method)
    if (peak.method == "parabola") {
        loc.max <- loc.max[loc.max >= oneside.min + 1 & loc.max <= 
            length(peak.base[, 2]) - oneside.min]
        all.peaks <- lapply(loc.max, function(x) {
            locs <- x + ((-num.pts + oneside.min + 1):(num.pts - 
                oneside.min - 1))
            locs <- locs[locs >= 1 & locs <= dim(peak.base)[1]]
            try(.peak.parab(peak.base[locs, ], num.pts, R2.thresh))
        })
        if (length(all.peaks) > 0) {
            all.peaks <- data.frame(do.call(rbind, all.peaks))
            all.peaks <- all.peaks[all.peaks[, 3] > 0, , drop = F]
        }
        else {
            all.peaks <- data.frame(matrix(0, nrow = 0, ncol = 3))
        }
        names(all.peaks) <- c("Center_hat", "Max_hat", "Width_hat")
        if (dim(all.peaks)[1] > 0) {
            rownames(all.peaks) <- 1:dim(all.peaks)[1]
            for (i in 1:3) {
                all.peaks[, i] <- as.numeric(all.peaks[, i])
            }
        }
    }
    else if (peak.method == "locmaxes") {
        if (length(loc.max) > 0) {
            all.peaks <- data.frame(peak.base[loc.max, ], NA)
            rownames(all.peaks) <- 1:dim(all.peaks)[1]
        }
        else {
            all.peaks <- data.frame(matrix(0, nrow = 0, ncol = 3))
        }
        names(all.peaks) <- c("Center_hat", "Max_hat", "Width_hat")
    }
    all.peaks
}
```

## New Version

```{r new_functions}
.centered.coeffs2 <- function (M) 
{
    Y <- M[, 2]
    X <- M[, 1] - mean(M[, 1])
    X2 <- X^2
    
    fit_data <- data.frame(Y = Y, X = X, X2 = X2)
    mod_data <- stats::lm(Y ~ X + X2, data = fit_data)
    stats::coefficients(mod_data)
}

.peak.parab2 <- function (pts, num.pts, R2.thresh) 
{
    Rsq <- sapply(1:(dim(pts)[1] - num.pts + 1), function(x) {
        FTICRMS::.Rsquared(pts[x + (0:(num.pts - 1)), ])
    })
    if (max(Rsq) >= R2.thresh) {
        locs <- which.max(Rsq) + (0:(num.pts - 1))
        coeffs <- .centered.coeffs2(pts[locs, ])
        return(c(mean(pts[locs, 1]) - coeffs[2]/2/coeffs[3], 
            coeffs[1] - coeffs[2]^2/4/coeffs[3], -1/coeffs[3]))
    }
    else {
        return(rep(0, 3))
    }
}

locate.peaks2 <- function (peak.base, num.pts = 5, R2.thresh = 0.98, oneside.min = 1, 
    peak.method = c("parabola", "locmaxes"), thresh = -Inf) 
{
    loc.max <- FTICRMS::.loc.maxes(peak.base[, 2])
    loc.max <- intersect(which(peak.base[, 2] >= thresh), loc.max)
    peak.method <- match.arg(peak.method)
    if (peak.method == "parabola") {
        loc.max <- loc.max[loc.max >= oneside.min + 1 & loc.max <= 
            length(peak.base[, 2]) - oneside.min]
        all.peaks <- lapply(loc.max, function(x) {
            locs <- x + ((-num.pts + oneside.min + 1):(num.pts - 
                oneside.min - 1))
            locs <- locs[locs >= 1 & locs <= dim(peak.base)[1]]
            try(.peak.parab2(peak.base[locs, ], num.pts, R2.thresh))
        })
        if (length(all.peaks) > 0) {
            all.peaks <- data.frame(do.call(rbind, all.peaks))
            all.peaks <- all.peaks[all.peaks[, 3] > 0, , drop = F]
        }
        else {
            all.peaks <- data.frame(matrix(0, nrow = 0, ncol = 3))
        }
        names(all.peaks) <- c("Center_hat", "Max_hat", "Width_hat")
        if (dim(all.peaks)[1] > 0) {
            rownames(all.peaks) <- 1:dim(all.peaks)[1]
            for (i in 1:3) {
                all.peaks[, i] <- as.numeric(all.peaks[, i])
            }
        }
    }
    else if (peak.method == "locmaxes") {
        if (length(loc.max) > 0) {
            all.peaks <- data.frame(peak.base[loc.max, ], NA)
            rownames(all.peaks) <- 1:dim(all.peaks)[1]
        }
        else {
            all.peaks <- data.frame(matrix(0, nrow = 0, ncol = 3))
        }
        names(all.peaks) <- c("Center_hat", "Max_hat", "Width_hat")
    }
    all.peaks
}
```


## Run Them!

```{r run_peaks}
scan_data <- as.matrix(scan_level)
scan_data[, 2] <- log_with_min(scan_data[, 2, drop = FALSE])
peaks1 <- locate.peaks(scan_data)

peaks2 <- locate.peaks2(scan_data)
```

So, something weird, is that they don't just evaluate all of the possible peak
points for fit to Rsquared and then fit on those. For example, running `FTICRMS::.Rsquared` on
`pts[6:13]` returns a value of 0.99, implying they fit the polynomial extremely well. So
these are the points that define the peak. 

Could we run really simple peak finding (i.e. the regex method), and then check 
for fit above a particular level, testing the range of points going from both sides
to make sure we have all possible combinations, and then generate the fit, and
integrate to get the peak area.
dropping points as needed. 
