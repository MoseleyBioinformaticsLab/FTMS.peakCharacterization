---
title: "Transient Level Peak Picking"
author: "Robert M Flight"
date: "`r Sys.time()`"
commit: "`r substr(git2r::branch_target(git2r::head(git2r::repository())), 1, 8)`"
output: 
  pdf_document: 
    toc: yes
---

# Purpose

Working out how to do transient level peak picking.

# Data

Lets load up some data working at the transient level.

```{r load_transient_level}
library(notifier)

library(xcms)
library(dplyr)
library(ggplot2)
library(SIRM.FTMS.peakPickingMethods)
library(ggplot2)
options(digits = 16)
```

So, our basic idea is to start very simply, and then escalate for peaks where the
simple things don't work. This requires us to set some simple metrics that tell
us whether or not a peak was likely picked correctly.

The steps I am imagining are:

* Classify as a flat or pointed peak
  * This is important because it changes how we handle looking at the center from
  the model.
* Fit a parabolic model to log-transformed values
* Flat peaks: check that center intensity is above max point, and between the flat points
* Pointed peaks: check that center intensity is within a weighted value of max, and near to it
* If checks fail, then:
* Try weighted parabolic fit, where weights are derived from point intensities
* Check again
* Try weighted **cauchy** fit
* Record generated parameters, and whether sanity checks pass for a peak.

## Peak Correspondence

We've got a bunch of methods for summarizing the peaks down to a single location
and intensity, now we need to figure out which one is best and most consistent.
To help with this, we need to match up the peaks across scans and get peak
correspondence. Lets play with that.

For peak correspondence, we need to set sensible limits for searching for a 
matching peak. To start, we will use a limit based on the digital resolution.

After an initial pass at matching peaks, we might use a calculation of the 
standard deviation of a window of m/z. To enable this, we take a middle m/z 
(should be the actual value of a correspondent peak), and go so many m/z on either
side, and then take **all** of the peaks from all of the scans within that window,
and calculate their squared distance to (the main peak / their own correspondent peak)
and then divide by (the number of peaks total - the number of corresponding peaks).


```{r raw_data}
raw_92C <- RawMS$new("92Cpos.mzML", "92Cpos_metadata.json")
```

```{r digital_resolution}


all_scans <- lapply(seq(raw_92C$scan_range), function(in_scan){
  tmp_rawdata <- as.data.frame(xcms::getScan(raw_92C$raw_data, in_scan))
  filter_rawdata <- SIRM.FTMS.peakPickingMethods:::get_scan_nozeros(tmp_rawdata)
  filter_rawdata
})

all_scans_merge <- do.call(rbind, all_scans)
all_fit <- exponential_fit(all_scans_merge$mz, all_scans_merge$lag, n_exp = 3)$coefficients
all_fit <- data.frame(coef = all_fit, which = letters[1:4], type = "all")

scan_models <- lapply(seq(raw_92C$scan_range), function(in_scan){
  tmp_rawdata <- as.data.frame(xcms::getScan(raw_92C$raw_data, in_scan))
  filter_rawdata <- SIRM.FTMS.peakPickingMethods:::get_scan_nozeros(tmp_rawdata)
  tmp <- exponential_fit(filter_rawdata$mz, filter_rawdata$lag, n_exp = 3)$coefficients
  data.frame(coef = tmp, which = letters[1:4], type = "indiv")
})

scan_coeffs <- do.call(rbind, scan_models)

mean_coeffs <- dplyr::group_by(scan_coeffs, which) %>% dplyr::summarise(., coef = mean(coef))

library(ggforce)

ggplot(scan_coeffs, aes(x = which, y = coef)) + geom_sina(bins = 40) +
  geom_point(data = all_fit, color = "blue") +
  geom_point(data = mean_coeffs, color = "red") + 
  facet_wrap(~which, scales = "free")
```

Based on this, the coefficients aren't changing a whole lot.

Lets see what happens when we graph the predictions from both against each other

```{r graph_preds}
mean_pred <- data.frame(x = rep(all_scans[[1]]$mz, 2),
                        y = c(exponential_predict(mean_coeffs$coef, all_scans[[1]]$mz),
                              exponential_predict(all_fit$coef, all_scans[[1]]$mz)),
                        which = rep(c("mean", "all"), each = nrow(all_scans[[1]])))

ggplot(mean_pred, aes(x = x, y = y, color = which)) + geom_point()

tmp_pred <- data.frame(mean = filter(mean_pred, which == "mean") %>% select(., y),
                       all = filter(mean_pred, which == "all") %>% select(., y))
names(tmp_pred) <- c("mean", "all")
ggplot(tmp_pred, aes(x = mean, y = all)) + geom_point()

tmp_pred <- mutate(tmp_pred, diff = abs(mean - all))
tmp_pred$mz <- all_scans[[1]]$mz

ggplot(tmp_pred, aes(x = diff)) + geom_histogram(bins = 40)
```


ToDo's:

* Compare average fit and all data fit, see if they are comparable
* See if we can replace `parabolic_fit` with the `exponential_fit`, and whether
or not **we need to do mean centering first**, which has previously seemed really
important for the parabolic peak fitting.

```{r single_scan_check_centering}
raw_92C$set_scans(scan_range = 1)
scan_92C <- MultiScans$new(raw_92C)

test_peak <- scan_92C$scans[[1]]$peaks[[1]]$peak_data

weights <- test_peak$intensity / max(test_peak$intensity)

tp_model <- exponential_fit(test_peak$mz, test_peak$log_int, w = weights, n_exp = 2)

tp_res1 <- data.frame(mz = test_peak$mz, log_int = tp_model$fitted.values)

mz2 <- test_peak$mz - mean(test_peak$mz)
tp_model2 <- exponential_fit(mz2, test_peak$log_int, w = weights, n_exp = 2)

tp_res2 <- data.frame(mz = test_peak$mz, log_int = tp_model2$fitted.values)

ggplot(test_peak, aes(x = mz, y = log_int)) + geom_line() + geom_point() + geom_point(data = tp_res1, color = "red") + geom_point(data = tp_res2, color = "blue")


tp_model3 <- SIRM.FTMS.peakPickingMethods:::parabolic_fit(test_peak$mz, test_peak$log_int, w = weights)
all.equal(tp_model2, tp_model3)

# wait, is it the fact that the parabola shouldn't have an intercept??
x <- test_peak$mz - mean(test_peak$mz)
Y <- test_peak$log_int - mean(test_peak$log_int)
X <- matrix(c(rep(1, length(x)), x, x^2), nrow = length(x), ncol = 3)

tp_model4 <- lm.wfit(X, Y, w = weights)

tp_in4 <- data.frame(x = x, y = Y)
tp_res4 <- data.frame(x = x, y = tp_model4$fitted.values)

ggplot(tp_in4, aes(x = x, y = y)) + geom_line() + geom_point() + geom_point(data = tp_res4, color = "blue")
```


```{r get_peaks_from_multiple_scans, cache=TRUE, cache.lazy=FALSE}
options(mc.cores = 10)
multi_scan <- MultiScans$new(raw_92C)
```


```{r correspondence}

```


# Workflow for Transient-Level Peak Finding

* Transform to log-space
* Find peaks using `pracma::findpeaks`
* For each peak:
    * Check that non-zero points have significant area
    * Fit a parabolic model to non-zero points
    * Find the peak center and intensity based on the model
    * Integrate parabola and sides to get peak area


