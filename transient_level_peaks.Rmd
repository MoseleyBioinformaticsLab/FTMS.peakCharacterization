---
title: "Transient Level Peak Picking"
author: "Robert M Flight"
date: "`r Sys.time()`"
commit: "`r substr(git2r::branch_target(git2r::head(git2r::repository())), 1, 8)`"
output: 
  pdf_document: 
    toc: yes
---

# Purpose

Working out how to do transient level peak picking.

# Data

Lets load up some data working at the transient level.

```{r load_transient_level}
library(xcms)
library(dplyr)
library(ggplot2)
library(SIRM.FTMS.peakPickingMethods)
options(digits = 16)

mz_file <- "/home/rmflight/Projects/work/CESB/ftms.QC/mzML_exported/92Cpos.mzML"
rawdata <- xcms::xcmsRaw(mz_file, profstep = 0)
scan_level <- as.data.frame(xcms::getScan(rawdata, 1))

scan_test <- filter(scan_level, (mz >= 150.026) & (mz <= 150.0271))
mz_data <- scan_test
```

# Workflow for Transient-Level Peak Finding

* Transform to log-space
* Find peaks using `pracma::findpeaks`
* For each peak:
    * Find longest set of peaks that have high r-squared to parabolic
    * Fit a parabolic model
    * Find the peak center and intensity based on the model
    * Integrate parabola and sides to get peak area

```{r peak_pick_one_transient}
scan_peaks <- find_peaks(scan_level)
```

# Trying to fix Parabolic Peak Picking

## Original

```{r original_functions}
.centered.coeffs <- function (M) 
{
    Y <- M[, 2]
    X <- M[, 1] - mean(M[, 1])
    Xb <- cbind(1, X, X^2)
    as.vector(Matrix::solve(t(Xb) %*% Xb, t(Xb) %*% Y, tol = 1e-18))
}

.peak.parab <- function (pts, num.pts, R2.thresh) 
{
    Rsq <- sapply(1:(dim(pts)[1] - num.pts + 1), function(x) {
        FTICRMS::.Rsquared(pts[x + (0:(num.pts - 1)), ])
    })
    if (max(Rsq) >= R2.thresh) {
        locs <- which.max(Rsq) + (0:(num.pts - 1))
        coeffs <- .centered.coeffs(pts[locs, ])
        return(c(mean(pts[locs, 1]) - coeffs[2]/2/coeffs[3], 
            coeffs[1] - coeffs[2]^2/4/coeffs[3], -1/coeffs[3]))
    }
    else {
        return(rep(0, 3))
    }
}

locate.peaks <- function (peak.base, num.pts = 5, R2.thresh = 0.98, oneside.min = 1, 
    peak.method = c("parabola", "locmaxes"), thresh = -Inf) 
{
    loc.max <- FTICRMS::.loc.maxes(peak.base[, 2])
    loc.max <- intersect(which(peak.base[, 2] >= thresh), loc.max)
    peak.method <- match.arg(peak.method)
    if (peak.method == "parabola") {
        loc.max <- loc.max[loc.max >= oneside.min + 1 & loc.max <= 
            length(peak.base[, 2]) - oneside.min]
        all.peaks <- lapply(loc.max, function(x) {
            locs <- x + ((-num.pts + oneside.min + 1):(num.pts - 
                oneside.min - 1))
            locs <- locs[locs >= 1 & locs <= dim(peak.base)[1]]
            try(.peak.parab(peak.base[locs, ], num.pts, R2.thresh))
        })
        if (length(all.peaks) > 0) {
            all.peaks <- data.frame(do.call(rbind, all.peaks))
            all.peaks <- all.peaks[all.peaks[, 3] > 0, , drop = F]
        }
        else {
            all.peaks <- data.frame(matrix(0, nrow = 0, ncol = 3))
        }
        names(all.peaks) <- c("Center_hat", "Max_hat", "Width_hat")
        if (dim(all.peaks)[1] > 0) {
            rownames(all.peaks) <- 1:dim(all.peaks)[1]
            for (i in 1:3) {
                all.peaks[, i] <- as.numeric(all.peaks[, i])
            }
        }
    }
    else if (peak.method == "locmaxes") {
        if (length(loc.max) > 0) {
            all.peaks <- data.frame(peak.base[loc.max, ], NA)
            rownames(all.peaks) <- 1:dim(all.peaks)[1]
        }
        else {
            all.peaks <- data.frame(matrix(0, nrow = 0, ncol = 3))
        }
        names(all.peaks) <- c("Center_hat", "Max_hat", "Width_hat")
    }
    all.peaks
}
```

## New Version

```{r new_functions}
.centered.coeffs2 <- function (M) 
{
    Y <- M[, 2]
    X <- M[, 1] - mean(M[, 1])
    X2 <- X^2
    
    fit_data <- data.frame(Y = Y, X = X, X2 = X2)
    mod_data <- stats::lm(Y ~ X + X2, data = fit_data)
    stats::coefficients(mod_data)
}

.peak.parab2 <- function (pts, num.pts, R2.thresh) 
{
    Rsq <- sapply(1:(dim(pts)[1] - num.pts + 1), function(x) {
        FTICRMS::.Rsquared(pts[x + (0:(num.pts - 1)), ])
    })
    if (max(Rsq) >= R2.thresh) {
        locs <- which.max(Rsq) + (0:(num.pts - 1))
        coeffs <- .centered.coeffs2(pts[locs, ])
        return(c(mean(pts[locs, 1]) - coeffs[2]/2/coeffs[3], 
            coeffs[1] - coeffs[2]^2/4/coeffs[3], -1/coeffs[3]))
    }
    else {
        return(rep(0, 3))
    }
}

locate.peaks2 <- function (peak.base, num.pts = 5, R2.thresh = 0.98, oneside.min = 1, 
    peak.method = c("parabola", "locmaxes"), thresh = -Inf) 
{
    loc.max <- FTICRMS::.loc.maxes(peak.base[, 2])
    loc.max <- intersect(which(peak.base[, 2] >= thresh), loc.max)
    peak.method <- match.arg(peak.method)
    if (peak.method == "parabola") {
        loc.max <- loc.max[loc.max >= oneside.min + 1 & loc.max <= 
            length(peak.base[, 2]) - oneside.min]
        all.peaks <- lapply(loc.max, function(x) {
            locs <- x + ((-num.pts + oneside.min + 1):(num.pts - 
                oneside.min - 1))
            locs <- locs[locs >= 1 & locs <= dim(peak.base)[1]]
            try(.peak.parab2(peak.base[locs, ], num.pts, R2.thresh))
        })
        if (length(all.peaks) > 0) {
            all.peaks <- data.frame(do.call(rbind, all.peaks))
            all.peaks <- all.peaks[all.peaks[, 3] > 0, , drop = F]
        }
        else {
            all.peaks <- data.frame(matrix(0, nrow = 0, ncol = 3))
        }
        names(all.peaks) <- c("Center_hat", "Max_hat", "Width_hat")
        if (dim(all.peaks)[1] > 0) {
            rownames(all.peaks) <- 1:dim(all.peaks)[1]
            for (i in 1:3) {
                all.peaks[, i] <- as.numeric(all.peaks[, i])
            }
        }
    }
    else if (peak.method == "locmaxes") {
        if (length(loc.max) > 0) {
            all.peaks <- data.frame(peak.base[loc.max, ], NA)
            rownames(all.peaks) <- 1:dim(all.peaks)[1]
        }
        else {
            all.peaks <- data.frame(matrix(0, nrow = 0, ncol = 3))
        }
        names(all.peaks) <- c("Center_hat", "Max_hat", "Width_hat")
    }
    all.peaks
}
```


## Run Them!

```{r run_peaks}
scan_data <- as.matrix(scan_level)
scan_data[, 2] <- SIRM.FTMS.peakPickingMethods:::log_with_min(scan_data[, 2, drop = FALSE])
peaks1 <- locate.peaks(scan_data)

peaks2 <- locate.peaks2(scan_data)

all.equal(peaks1, peaks2)
```

# Compare My Code and Theirs

Given that I've essentially rewritten the parabolic based peak finding code, we
should compare them to each other to make sure that the results are not too different.



