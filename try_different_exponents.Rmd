---
title: "checking exponents"
author: "Robert M Flight"
date: "`r Sys.time()`"
output: pdf_document
---

```{r setup, message=FALSE, warning=FALSE}
library(SIRM.FTMS.peakCharacterization)
library(cowplot)
library(dplyr)
```


## Purpose

Some fits are producing what appear to be negative interecepts at low SD. There
are two ways to fix this:

  1. Use a higher order exponential
  2. Set the intercept to be 0, 0
  
However, we need to be sure we aren't making things worse by doing this, that the
lines still follow the data over the different samples that we have, and that
the residuals aren't going to get completely messed up.

## Executive Summary

Outside of cubic with no intercept, appears to be a mixed bag, really. None seems
to be qualitatively better than another for this part, although in all cases the
actual residuals are really quite low. 

So, overall, the quartic with an intercept of 0 (`q4_noint`) seems to be our best
bet, so we will go with that at this time.


## New Functions

The two functions below implement a fit that explicitly considers a Y (SD) intercept
of **0**.


```{r new_functions}
exponential_fit2 <- function(x, y, w = NULL, n_exp = 1, center = FALSE){
  if (center) {
    mean_x <- mean(x, na.rm = TRUE)
    center_x <- x - mean_x
  } else {
    center_x <- x
    mean_x <- 0
  }
  x_exp <- lapply(seq(1, n_exp), function(in_exp){
    center_x^in_exp
  })
  X <- do.call(cbind, x_exp)

  if (is.null(w)) {
    out_fit <- stats::lm.fit(X, y)
  } else {
    out_fit <- stats::lm.wfit(X, y, w)
  }
  names(out_fit$coefficients) <- NULL

  out_fit$mean_x <- mean_x
  out_fit
}

exponential_predict2 <- function(coef, x){
  n_exp <- seq(0, length(coef))

  x_exp <- lapply(n_exp, function(in_exp){
    x^in_exp
  })
  X <- do.call(cbind, x_exp)

  Y <- X %*% c(0, coef)
  Y
}
```


## Data

The data we will work with is some `multi-scan-peaklists` for two samples
from each data set.

```{r data_files}
data_files <- dir("test_files/mspl_files_fit4", full.names = TRUE)
```

## Procedure

For each scan in each file, perform a fit using 4 different methods:

  1. Cubic with intercept
  2. Cubic without intercept
  3. Quartic with intercept
  4. Quartic without intercept
  
Where **without** intercept means that the Y-intercept is forced to zero.

The residuals will be compared to the base case (cubic w/ intercept) for the other
three.

## Do It

```{r run_analysis, results='hide', message=FALSE, warning=FALSE}
predict_sd <- lapply(data_files, function(in_file){
  tmp_env <- new.env()
  load(in_file, envir = tmp_env)
  
  lag_info <- tmp_env$raw_residuals
  rm(tmp_env)
  
  n_scan <- length(lag_info)
  
  per_scan <- invisible(lapply(seq(1, n_scan), function(use_scan){
    in_scan <- lag_info[[use_scan]]
    c3_int <- exponential_fit(in_scan$scan$mz, in_scan$scan$lag, n_exp = 3)
    c3_noint <- exponential_fit2(in_scan$scan$mz, in_scan$scan$lag, n_exp = 3)
    
    q4_int <- exponential_fit(in_scan$scan$mz, in_scan$scan$lag, n_exp = 4)
    q4_noint <- exponential_fit2(in_scan$scan$mz, in_scan$scan$lag, n_exp = 4)
    
    fitted_values <- list(org = data.frame(mz = in_scan$scan$mz, sd = in_scan$scan$lag, type = "org"),
      c3_int = data.frame(mz = in_scan$scan$mz, sd = c3_int$fitted.values, type = "c3_int"),
      c3_noint = data.frame(mz = in_scan$scan$mz, sd = c3_noint$fitted.values, type = "c3_noint"),
      q4_int = data.frame(mz = in_scan$scan$mz, sd = q4_int$fitted.values, type = "q4_int"),
      q4_noint = data.frame(mz = in_scan$scan$mz, sd = q4_noint$fitted.values, type = "q4_noint"))
    
    fitted_values <- do.call(rbind, fitted_values)
    residual_values <- list(c3_int = data.frame(mz = in_scan$scan$mz, resid = c3_int$residuals, type = "c3_int"),
                            c3_noint = data.frame(mz = in_scan$scan$mz, resid = c3_noint$residuals, type = "c3_noint"),
                            q4_int = data.frame(mz = in_scan$scan$mz, resid = q4_int$residuals, type = "q4_int"),
                            q4_noint = data.frame(mz = in_scan$scan$mz, resid = q4_noint$residuals, type = "q4_noint"))
  
    residual_values <- do.call(rbind, residual_values)
    
    residual_ratio <- list(c3_noint = data.frame(mz = in_scan$scan$mz, ratio = c3_noint$residuals / c3_int$residuals, type = "c3_noint"),
                           q4_int = data.frame(mz = in_scan$scan$mz, ratio = q4_int$residuals / c3_int$residuals, type = "q4_int"),
                           q4_noint = data.frame(mz = in_scan$scan$mz, ratio = q4_noint$residuals / c3_int$residuals, type = "q4_noint"))
    residual_ratio <- do.call(rbind, residual_ratio)
    
    residual_summary <- dplyr::group_by(residual_ratio, type) %>% 
      summarise(., mean = mean(log10(ratio), na.rm = TRUE), median = median(log10(ratio), na.rm = TRUE), sd = sd(log10(ratio), na.rm = TRUE)) %>%
      mutate(., scan = use_scan)
    
    list(fit = fitted_values,
         resid = residual_values,
         ratio = residual_ratio,
         summary = residual_summary)
    
  }))
  
  just_summary <- lapply(per_scan, function(x){x$summary})
  just_summary <- do.call(rbind, just_summary)
  
  list(summary = just_summary, all = per_scan)
})
```

## Examine Summaries

```{r}
lapply(predict_sd, function(in_sd){
  ggplot(in_sd$summary, aes(x = mean, fill = type)) + geom_histogram(alpha = 0.5, position = "identity", bins = 100)
})
```

## Examine Subsets

Lets also actually plot some subsets of the scans in each of the data. 

### File 1

```{r file1, dev='CairoPNG', dpi = 200}
file1 <- predict_sd[[1]]
use_scans <- sample(length(file1$all), 10)

for (iscan in use_scans) {
  point_data <- filter(file1$all[[iscan]]$fit, type == "org")
  other_data <- filter(file1$all[[iscan]]$fit, type != "org")
  p <- ggplot(point_data, aes(x = mz, y = sd, color = type)) + geom_point(alpha = 0.5) + geom_line(data = other_data)
  print(p)
  q <- ggplot(file1$all[[iscan]]$resid, aes(x = mz, y = resid, color = type)) + geom_point(alpha = 0.5) +
    ylim(c(-2.5e-5, 2.5e-5))
  print(q)
}
```

### File 2

```{r file2, dev='CairoPNG', dpi = 200}
file2 <- predict_sd[[2]]
use_scans <- sample(length(file2$all), 10)

for (iscan in use_scans) {
  point_data <- filter(file2$all[[iscan]]$fit, type == "org")
  other_data <- filter(file2$all[[iscan]]$fit, type != "org")
  p <- ggplot(point_data, aes(x = mz, y = sd, color = type)) + geom_point(alpha = 0.5) + geom_line(data = other_data)
  print(p)
  q <- ggplot(file2$all[[iscan]]$resid, aes(x = mz, y = resid, color = type)) + geom_point(alpha = 0.5) +
    ylim(c(-2.5e-5, 2.5e-5))
  print(q)
}
```

### File 3

```{r file3, dev='CairoPNG', dpi = 200}
file3 <- predict_sd[[3]]
use_scans <- sample(length(file3$all), 10)

for (iscan in use_scans) {
  point_data <- filter(file3$all[[iscan]]$fit, type == "org")
  other_data <- filter(file3$all[[iscan]]$fit, type != "org")
  p <- ggplot(point_data, aes(x = mz, y = sd, color = type)) + geom_point(alpha = 0.5) + geom_line(data = other_data)
  print(p)
  q <- ggplot(file3$all[[iscan]]$resid, aes(x = mz, y = resid, color = type)) + geom_point(alpha = 0.5) +
    ylim(c(-2.5e-5, 2.5e-5))
  print(q)
}
```

### File 4

```{r file4, dev='CairoPNG', dpi = 200}
file4 <- predict_sd[[4]]
use_scans <- sample(length(file4$all), 10)

for (iscan in use_scans) {
  point_data <- filter(file4$all[[iscan]]$fit, type == "org")
  other_data <- filter(file4$all[[iscan]]$fit, type != "org")
  p <- ggplot(point_data, aes(x = mz, y = sd, color = type)) + geom_point(alpha = 0.5) + geom_line(data = other_data)
  print(p)
  q <- ggplot(file4$all[[iscan]]$resid, aes(x = mz, y = resid, color = type)) + geom_point(alpha = 0.5) +
    ylim(c(-2.5e-5, 2.5e-5))
  print(q)
}
```


### File 5

```{r file5, dev='CairoPNG', dpi = 200}
file5 <- predict_sd[[5]]
use_scans <- sample(length(file5$all), 10)

for (iscan in use_scans) {
  point_data <- filter(file5$all[[iscan]]$fit, type == "org")
  other_data <- filter(file5$all[[iscan]]$fit, type != "org")
  p <- ggplot(point_data, aes(x = mz, y = sd, color = type)) + geom_point(alpha = 0.5) + geom_line(data = other_data)
  print(p)
  q <- ggplot(file5$all[[iscan]]$resid, aes(x = mz, y = resid, color = type)) + geom_point(alpha = 0.5) +
    ylim(c(-2.5e-5, 2.5e-5))
  print(q)
}
```

