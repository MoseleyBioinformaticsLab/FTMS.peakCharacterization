---
title: "checking exponents"
author: "Robert M Flight"
date: "`r Sys.time`"
output:
  pdf_document:
    toc: yes
---

```{r setup, message=FALSE, warning=FALSE}
library(SIRM.FTMS.peakCharacterization)
library(cowplot)
library(dplyr)
```


## Purpose

Some fits are producing what appear to be negative interecepts at low SD. There
are two ways to fix this:

  1. Use a higher order exponential
  2. Set the intercept to be 0, 0
  
However, we need to be sure we aren't making things worse by doing this, that the
lines still follow the data over the different samples that we have, and that
the residuals aren't going to get completely messed up.

## Executive Summary

....


## New Functions

The two functions below implement a fit that explicitly considers a Y (SD) intercept
of **0**.


```{r new_functions}
exponential_fit2 <- function(x, y, w = NULL, n_exp = 1, center = FALSE){
  if (center) {
    mean_x <- mean(x, na.rm = TRUE)
    center_x <- x - mean_x
  } else {
    center_x <- x
    mean_x <- 0
  }
  x_exp <- lapply(seq(1, n_exp), function(in_exp){
    center_x^in_exp
  })
  X <- do.call(cbind, x_exp)

  if (is.null(w)) {
    out_fit <- stats::lm.fit(X, y)
  } else {
    out_fit <- stats::lm.wfit(X, y, w)
  }
  names(out_fit$coefficients) <- NULL

  out_fit$mean_x <- mean_x
  out_fit
}

exponential_predict2 <- function(coef, x){
  n_exp <- seq(0, length(coef))

  x_exp <- lapply(n_exp, function(in_exp){
    x^in_exp
  })
  X <- do.call(cbind, x_exp)

  Y <- X %*% c(0, coef)
  Y
}
```


## Data

The data we will work with is some `multi-scan-peaklists` for two samples
from each data set.

```{r data_files}
data_files <- dir("test_files/mspl_files_fit4", full.names = TRUE)
```

## Procedure

For each scan in each file, perform a fit using 4 different methods:

  1. Cubic with intercept
  2. Cubic without intercept
  3. Quartic with intercept
  4. Quartic without intercept
  
Where **without** intercept means that the Y-intercept is forced to zero.

The residuals will be compared to the base case (cubic w/ intercept) for the other
three.

## Do It

```{r run_analysis}
predict_sd <- lapply(data_files, function(in_file){
  tmp_env <- new.env()
  load(in_file, envir = tmp_env)
  
  lag_info <- tmp_env$raw_residuals
  rm(tmp_env)
  
  n_scan <- length(lag_info)
  
  per_scan <- invisible(lapply(seq(1, n_scan), function(use_scan){
    in_scan <- lag_info[[use_scan]]
    c3_int <- exponential_fit(in_scan$scan$mz, in_scan$scan$lag, n_exp = 3)
    c3_noint <- exponential_fit2(in_scan$scan$mz, in_scan$scan$lag, n_exp = 3)
    
    q4_int <- exponential_fit(in_scan$scan$mz, in_scan$scan$lag, n_exp = 4)
    q4_noint <- exponential_fit2(in_scan$scan$mz, in_scan$scan$lag, n_exp = 4)
    
    fitted_values <- list(org = data.frame(mz = in_scan$scan$mz, sd = in_scan$scan$lag, type = "org"),
      c3_int = data.frame(mz = in_scan$scan$mz, sd = c3_int$fitted.values, type = "c3_int"),
      c3_noint = data.frame(mz = in_scan$scan$mz, sd = c3_noint$fitted.values, type = "c3_noint"),
      q4_int = data.frame(mz = in_scan$scan$mz, sd = q4_int$fitted.values, type = "q4_int"),
      q4_noint = data.frame(mz = in_scan$scan$mz, sd = q4_noint$fitted.values, type = "q4_noint"))
    
    fitted_values <- do.call(rbind, fitted_values)
    residual_values <- list(c3_int = data.frame(mz = in_scan$scan$mz, resid = c3_int$residuals, type = "c3_int"),
                            c3_noint = data.frame(mz = in_scan$scan$mz, resid = c3_noint$residuals, type = "c3_noint"),
                            q4_int = data.frame(mz = in_scan$scan$mz, resid = q4_int$residuals, type = "q4_int"),
                            q4_noint = data.frame(mz = in_scan$scan$mz, resid = q4_noint$residuals, type = "q4_noint"))
  
    residual_values <- do.call(rbind, residual_values)
    
    residual_ratio <- list(c3_noint = data.frame(mz = in_scan$scan$mz, ratio = c3_noint$residuals / c3_int$residuals, type = "c3_noint"),
                           q4_int = data.frame(mz = in_scan$scan$mz, ratio = q4_int$residuals / c3_int$residuals, type = "q4_int"),
                           q4_noint = data.frame(mz = in_scan$scan$mz, ratio = q4_noint$residuals / c3_int$residuals, type = "q4_noint"))
    residual_ratio <- do.call(rbind, residual_ratio)
    
    residual_summary <- dplyr::group_by(residual_ratio, type) %>% 
      summarise(., mean = mean(log10(ratio), na.rm = TRUE), median = median(log10(ratio), na.rm = TRUE), sd = sd(log10(ratio), na.rm = TRUE)) %>%
      mutate(., scan = use_scan)
    
    list(fit = fitted_values,
         resid = residual_values,
         ratio = residual_ratio,
         summary = residual_summary)
    
  }))
  
  just_summary <- lapply(per_scan, function(x){x$summary})
  just_summary <- do.call(rbind, just_summary)
  
  list(summary = just_summary, all = per_scan)
})
```

## Examine Summaries

```{r}
lapply(predict_sd, function(in_sd){
  ggplot(in_sd$summary, aes(x = mean, fill = type)) + geom_histogram(alpha = 0.5, position = "identity", bins = 100)
})
```

