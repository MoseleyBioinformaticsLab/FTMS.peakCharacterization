## New Correspondent Peak Finding Method

This is to work out how to generate the final correspondent peaks based on 
smashing all the scan data together.

## Data

```{r packages}
library(SIRM.FTMS.peakCharacterization)
library(furrr)
plan(multiprocess)
```

We will use a dataset where only peak correspondence has been done.

```{r load_data_setup, eval = FALSE}
library(SIRM.FTMS.peakCharacterization)
library(furrr)
plan(multiprocess)
raw_data <- RawMS$new("100Cpos.mzML")
tictoc::tic()
start_time <- Sys.time()

raw_data$remove_bad_resolution_scans()

raw_time <- difftime(Sys.time(), start_time)

pr_finder <- PeakRegionFinder$new(raw_data)

pr_finder$add_sliding_regions()
pr_finder$add_tiled_regions()

add_window_time <- difftime(Sys.time(), start_time)

pr_finder$reduce_sliding_regions()

reduce_window_time <- difftime(Sys.time(), start_time)

pr_finder$split_peak_regions()

initial_split_time <- difftime(Sys.time(), start_time)

pr_finder$normalize_data()

pr_finder$find_peaks_in_regions()

finding_peak_time <- difftime(Sys.time(), start_time)

tictoc::toc()
```

This took about 30 minutes, with 20 of that being the peak characterization within the determined regions.

## Load Data

```{r setup_modeling}
library(SIRM.FTMS.peakCharacterization)
library(ggplot2)

```

```{r load_data}
pr_1 <- readRDS("100Cpos_regional.rds")
multi_scan_peaks <- pr_1$peak_regions$peak_data
pr_2 <- readRDS("100Cpos_regional_2.rds")
indiv_scan_peaks <- pr_2$peak_regions$peak_data

rm(pr_1)
rm(pr_2)
```

## Do We Need Models

### Model MZ SD

```{r mzsd, fig.keep="all"}
p_mzsd <- ggplot(multi_scan_peaks, aes(x = ObservedMZ, y = ObservedMZSD)) + geom_point() + geom_smooth()
p_mzsd

p_mzsd + ylim(c(0, 0.01))

p_mzsd + geom_point(aes(color = NScan)) + ylim(c(0, 0.01))
```

```{r mzsd_factor}
p_mzsd_factor <- ggplot(multi_scan_peaks, aes(x = log10(Height), y = ObservedMZSD)) + geom_point()
p_mzsd_factor

p_mzsd_factor + ylim(c(0, 0.01))

p_mzsd_factor + geom_point(aes(color = NSubset)) + ylim(c(0, 0.01))
```

So, this implies that we should do a model for the M/Z SD. Can't see how we might
decide to use the model over the **calculated** value, as there isn't a clear


### Model Log10HeightSD

```{r heightsd}
p_heightsd <- ggplot(multi_scan_peaks, aes(x = log10(Height), y = Log10HeightSD)) + geom_point() + geom_smooth()
p_heightsd
```

We can also model the `Log10HeightSD` as a property of the `log10(Height)`.

Can we determine when to use the model instead of the computed value?

```{r when_model}
p_heightsd + geom_point(aes(color = NSubset))
```

Doesn't look like it, no.

## Compare Peaks

Lets compare some of the peak metrics.

```{r join_data}
both_peaks <- dplyr::left_join(multi_scan_peaks, indiv_scan_peaks, by = "PeakID",
                               suffix = c(".multi", ".indiv"))
multi_scan_peaks$Type <- "Multi"
indiv_scan_peaks$Type <- "Indiv"

all_peaks <- rbind(dplyr::select(multi_scan_peaks, -SSR, -type), indiv_scan_peaks)
```

Width in frequency space??

### Compare Height Values

```{r compare_height}
ggplot(both_peaks, aes(x = log10(Height.multi), y = log10(Height.indiv))) + geom_point()
```

```{r compare_heightsd}
ggplot(both_peaks, aes(x = Log10HeightSD.multi, y = Log10HeightSD.indiv, color = NSubset.multi)) + geom_point()
```

```{r compare_heightrsd, fig.keep = "all"}
ggplot(both_peaks, aes(x = HeightSD.multi / Height.multi, y = HeightSD.indiv / Height.indiv)) + geom_point() + xlim(c(0, 1)) + geom_abline(slope = 1, intercept = 0, color = "red") + geom_abline(slope = 1.4, intercept = , color = "blue")

both_peaks <- dplyr::mutate(both_peaks, rsd_ratio = (HeightSD.multi / Height.multi) / (HeightSD.indiv / Height.indiv))

ggplot(dplyr::filter(both_peaks, rsd_ratio <= 3), aes(x = rsd_ratio)) + geom_histogram(bins = 100) +
  labs(x = "Ratio of Multi-RSD to Indiv-RSD")

all_peaks <- dplyr::mutate(all_peaks, HeightRSD = HeightSD / Height)
ggplot(dplyr::filter(all_peaks, HeightRSD <= 0.5), aes(x = HeightRSD, color = Type)) + geom_density()
```

So, basically we halved our RSD values. Yay us!

### Compare M/Z Values

```{r compare_mz_locs}
ggplot(both_peaks, aes(x = log(ObservedMZ.multi), y = log(ObservedMZ.indiv))) + geom_point() + geom_abline(slope = 1, intercept = 0, color = "red")
```

Note that we will scale the differences by the point-to-point offset to account
for the fact that we expect to see larger differences the higher we go in M/Z.

```{r match_points_to_offsets}
pr_1 <- readRDS("100Cpos_regional.rds")
point_model <- pr_1$peak_regions$mz_model

peak_offset <- purrr::map_df(multi_scan_peaks$PeakID, function(in_peak){
  use_mz <- multi_scan_peaks$ObservedMZ[multi_scan_peaks$PeakID %in% in_peak]
  out_offset <- point_model$y[which.min(abs(point_model$x - use_mz))]
  data.frame(PeakID = in_peak, Offset = out_offset)
})

both_peaks <- dplyr::left_join(both_peaks, peak_offset, by = "PeakID")
```

```{r examine_mz_diffs, fig.keep = "all"}
both_peaks <- dplyr::mutate(both_peaks, MZDiff = (ObservedMZ.multi - ObservedMZ.indiv) / Offset)

ggplot(dplyr::filter(both_peaks, abs(MZDiff) <= 0.5), aes(x = MZDiff)) + geom_histogram(bins = 100)

ggplot(dplyr::filter(both_peaks, abs(MZDiff) <= 0.5), aes(x = ObservedMZ.multi, y = MZDiff, color = log10(Height.multi))) + geom_point()

ggplot(dplyr::filter(both_peaks, abs(MZDiff) <= 0.5), aes(x = log10(Height.multi), y = MZDiff)) + geom_point()
```

This final figure makes sense. 
