---
title: "R03 Progress Report"
author: "Robert M Flight"
date: "`r Sys.time()`"
output: word_document
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
```


```{r packages_used}
library(SIRM.FTMS.peakCharacterization)
library(cowplot)
library(dplyr)
library(xcms)
```

```{r directories}
use_files <- dir("test_files/mspl_files_defaults_X2017.05.22.12.00.46", pattern = "aspear", full.names = TRUE)[1]
figure_loc <- "r03_report_figs"
if (!dir.exists(figure_loc)) {
  dir.create(figure_loc)
}
```

```{r load_data}
load(use_files)
```

## Purpose

Provide figures for the R03 progress report.

## Data

One of the exosomal lipid extracts performed by Amanda Spear.

## Noise Levels

### Single Scan

```{r}
scan_noise_plots <- function(peak_list_by_scans){
  all_plots <- lapply(peak_list_by_scans, function(in_scan){
    peak_list <- in_scan$peak_list
    peak_list <- mutate(peak_list, log10_height = log10(Height))
    
    p <- ggplot(peak_list, aes(x = log10_height, fill = not_noise)) + geom_histogram(bins = 100) + 
      ggtitle(as.character(in_scan$scan))
    p
  })
}
```


```{r single_scan_noise}
single_scan_peaklist <- peak_finder$multi_scan_peaklist$peak_list_by_scans[[4]]$peak_list
single_scan_peaklist <- mutate(single_scan_peaklist, log10_height = log10(Height))

noise_loc <- data.frame(noise = peak_finder$multi_scan_peaklist$noise_info$noise[1],
                        thresh = log10(peak_finder$multi_scan_peaklist$noise_info$threshold[1]))

single_scan_noiseplot <- ggplot(single_scan_peaklist, aes(x = log10_height, fill = not_noise)) + geom_histogram(bins = 100, position = "identity") + geom_vline(data = noise_loc, aes(xintercept = noise), color = "red") + geom_vline(data = noise_loc, aes(xintercept = thresh), color = "blue")
single_scan_noiseplot
```

Figure 1. log-10 of peak heights within a single scan. 

These peak heights show a bimodal distribution that we believe is indicative 
of a noise and a signal component, and therefore can be 
separated prior to peak correspondence across scans, improving scan-to-scan peak
correspondence.

### Across Scans

```{r across_scan_noise}
across_scans <- peak_finder$multi_scan_peaklist$noise_info
across_scan_noise <- ggplot(across_scans, aes(x = noise)) + geom_histogram(bins = 50) + xlab("log10(noise)")
across_scan_noise
```

Figure 2. Log-10 of noise peaks across multiple scans for one sample. 

Figure 2 demonstrates that the noise levels across scans can vary, and although
it is often within a narrow range, sometimes some of the scans will be outside. Normalization
or removal of the outlier scans may improve the analysis.

## Correspondece Depth

```{r correspondence_depth}
mpl <- peak_finder$correspondent_peaks$master_peak_list

mpl2 <- mpl$clone(deep = TRUE)
mpl2 <- collapse_correspondent_peaks(mpl2)

n_peaks <- mpl2$count_notna()
n_peaks <- sort(n_peaks)
rle_peaks <- rle(n_peaks)
corr_depth <- data.frame(n_scan = rle_peaks$values, n_peak = rle_peaks$lengths)

n_scan <- data.frame(n_scan = n_peaks)

corr_depth_plot <- ggplot(n_scan, aes(x = n_scan)) + geom_histogram(bins = 56) + ylab("n_peak")
corr_depth_plot
```

Figure 3. Number of correspondent-peaks with a given number of peaks across the scans.

Following correspondence of the peaks across the scans, the number of individual
scan-peaks for each correspondent peak can be assessed. More than 2000 of the peaks
appear in only a single scan, seeding doubt as to whether they are **real** peaks
or some form of artifact. In contrast, `r sum(n_peaks >= 5)` are present in
at least 5 scans.

## Drop In Peaks Before / After Scan Level Correspondence

Base this on doing peak picking on the **averaged** scans.

```{r averaged_peak_picking}
raw_data <- peak_finder$raw_data$raw_data
profStep(raw_data) <- 0
averaged_data <- xcms::getSpec(raw_data)
averaged_data <- averaged_data[!(is.na(averaged_data[,2])), ]

peaks <- pracma::findpeaks(averaged_data[, 2], nups = 2, ndowns = 2)
peaks <- peaks[(peaks[,4] - peaks[,3]) >= 5, ]

max_peak <- max(peaks[,1]) * 0.00001
```

There are **`r nrow(peaks)`** with at least 5 data points, of which `r sum(peaks[,1] >= max_peak)` would remain
using a noise cutoff of 0.01% of the maximum peak.

```{r drop_in_peaks}
drop_peaks <- data.frame(condition = c("raw", "0.01%", "all_scans", "> 5 scans"),
                         n_peak = c(nrow(peaks), sum(peaks[,1] >= max_peak), length(n_peaks), sum(n_peaks >= 5)))

drop_peaks$condition <- forcats::fct_relevel(drop_peaks$condition, "raw", "0.01%", "all_scans", "> 5 scans")

drop_figure <- ggplot(drop_peaks, aes(x = condition, y = n_peak)) + geom_col()
drop_figure
```

Figure 4. Number of reported peaks under different conditions. **raw** are the
number of peaks with at least 5 data points peak-picked from the fully averaged
spectrum. **0.01%** is the number of **raw** peaks left after removing those
less than 0.01% the height of the highest peak. **all_scans** is the number of
peaks present in at least one scan after doing scan level peak picking and correspondence,
and **> 5 scans** is the number of peaks present in at least 5 scans.

Figure 4 demonstrates how much data reduction takes place through the use of
scan level peak picking and correspondence of peaks across scans. For this
one sample, the `r drop_peaks[4, "n_peak"]` peaks present in at least 5 scans
represents 3% of the peaks present when peak picking across the fully averaged
spectrum, and 9% of the peaks present after filtering out those peaks with
less than 0.01% of the intensity.

## Save to File

```{r save_to_file}
library(ReporteRs)
doc <- pptx()

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = single_scan_noiseplot, vector.graphic = TRUE)

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = across_scan_noise, vector.graphic = TRUE)

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = corr_depth_plot, vector.graphic = TRUE)

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = drop_figure, vector.graphic = TRUE)

writeDoc(doc, file = "r03_figures.pptx")
```

