---
title: "R03 Progress Report"
author: "Robert M Flight"
date: "`r Sys.time()`"
output: word_document
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
```


```{r packages_used}
library(SIRM.FTMS.peakCharacterization)
library(cowplot)
library(dplyr)
library(xcms)
```

```{r directories}
use_files <- dir("test_files/mspl_files_defaults_X2017.05.22.12.00.46", pattern = "aspear", full.names = TRUE)[1]
figure_loc <- "r03_report_figs"
if (!dir.exists(figure_loc)) {
  dir.create(figure_loc)
}
```

```{r load_data}
load(use_files)
```


```{r scan_noise_plot_function}
scan_noise_plots <- function(peak_list_by_scans){
  all_plots <- lapply(peak_list_by_scans, function(in_scan){
    peak_list <- in_scan$peak_list
    peak_list <- mutate(peak_list, log10_height = log10(Height))
    
    p <- ggplot(peak_list, aes(x = log10_height, fill = not_noise)) + geom_histogram(bins = 100) + 
      ggtitle(as.character(in_scan$scan))
    p
  })
}
```


```{r single_scan_noise}
single_scan_peaklist <- peak_finder$multi_scan_peaklist$peak_list_by_scans[[4]]$peak_list
single_scan_peaklist <- mutate(single_scan_peaklist, log10_height = log10(Height))

noise_loc <- data.frame(noise = peak_finder$multi_scan_peaklist$noise_info$noise[1],
                        thresh = log10(peak_finder$multi_scan_peaklist$noise_info$threshold[1]))

single_scan_noiseplot <- ggplot(single_scan_peaklist, aes(x = log10_height, fill = not_noise)) + geom_histogram(bins = 100, position = "identity") + geom_vline(data = noise_loc, aes(xintercept = noise), color = "red") + geom_vline(data = noise_loc, aes(xintercept = thresh), color = "blue")
single_scan_noiseplot
```

Figure 1. Example log-10 histogram of peak heights within a single scan. 

The first major lowest intensity mode is indicative noise, and therefore can be 
separated prior to peak correspondence across scans, improving scan-to-scan peak
correspondence.

```{r across_scan_noise}
across_scans <- peak_finder$multi_scan_peaklist$noise_info
across_scan_noise <- ggplot(across_scans, aes(x = noise)) + geom_histogram(bins = 50) + xlab("log10(noise)")
across_scan_noise
```

Figure 2. Log-10 histogram of noise levels across multiple scans for one sample. 

Figure 2 demonstrates that the noise levels across scans can vary, and although
it is often within a narrow range, sometimes some of the scans will be outside. 
Removal of outlier scans appears to improve the analysis.


```{r correspondence_depth}
mpl <- peak_finder$correspondent_peaks$master_peak_list

mpl2 <- mpl$clone(deep = TRUE)
mpl2 <- collapse_correspondent_peaks(mpl2)

n_peaks <- mpl2$count_notna()
n_peaks <- sort(n_peaks)
rle_peaks <- rle(n_peaks)
corr_depth <- data.frame(n_scan = rle_peaks$values, n_peak = rle_peaks$lengths)

n_scan <- data.frame(n_scan = n_peaks)

corr_depth_plot <- ggplot(n_scan, aes(x = n_scan)) + geom_histogram(bins = 56) + ylab("n_peak")
corr_depth_plot
```

Figure 3. Histogram of correspondent-peaks with a given number of peaks across scans.

Following correspondence of the peaks across the scans, the number of individual
scan-peaks for each correspondent peak can be assessed. More than 2000 of the peaks
appear in only a single scan, seeding doubt as to whether they are **real** peaks
or some form of artifact. In contrast, `r sum(n_peaks >= 5)` are present in
at least 5 scans.


```{r averaged_peak_picking}
raw_data <- peak_finder$raw_data$raw_data
profStep(raw_data) <- 0
averaged_data <- xcms::getSpec(raw_data)
averaged_data <- averaged_data[!(is.na(averaged_data[,2])), ]

peaks <- pracma::findpeaks(averaged_data[, 2], nups = 2, ndowns = 2)
peaks <- peaks[(peaks[,4] - peaks[,3]) >= 5, ]

max_peak <- max(peaks[,1]) * 0.00001
```


```{r drop_in_peaks}
drop_peaks <- data.frame(condition = c("raw", "0.01%", "all_scans", "> 5 scans"),
                         n_peak = c(nrow(peaks), sum(peaks[,1] >= max_peak), length(n_peaks), sum(n_peaks >= 5)))

drop_peaks$condition <- forcats::fct_relevel(drop_peaks$condition, "raw", "0.01%", "all_scans", "> 5 scans")

drop_figure <- ggplot(drop_peaks, aes(x = condition, y = n_peak)) + geom_col()
drop_figure
```

Figure 4. Number of reported peaks under different criteria. **raw** are the
number of peaks with at least 5 non-zero data points peak-picked from the fully averaged
spectrum. **0.01%** is the number of **raw** peaks left after removing those
less than 0.01% the height of the highest peak. **all_scans** is the number of
peaks present in at least one scan after doing scan level noise removal and peak correspondence,
and **> 5 scans** is the number of peaks present in at least 5 scans.

Figure 4 demonstrates how much data reduction takes place through the use of
scan level peak picking, noise removal, and correspondence of peaks across scans. For this
one sample, the `r drop_peaks[4, "n_peak"]` peaks present in at least 5 scans
represents 3% of the peaks present when peak picking across the fully averaged
spectrum, and 9% of the peaks present after filtering out those peaks with
less than 0.01% of the intensity.


```{r sample_correspondence_files, cache = TRUE}
cor_files <- dir("~/data/amandaspear/20161205_beadcaptureexotest_lipids_FTMS_ARS/peak_picked/inter_files_X2017.05.22.11.57.27", pattern = "pos", full.names = TRUE)

cor_mpl <- lapply(cor_files, function(in_file){
  tmp_env <- new.env()
  load(in_file, envir = tmp_env)
  mpl <- tmp_env$peak_finder$correspondent_peaks$master_peak_list$clone(deep = TRUE)
  rm(tmp_env)
  mpl
})

names(cor_mpl) <- basename(cor_files)
```

```{r setup_correspondence, cache = TRUE}
peakfinder <- new.env()
load(cor_files[1], envir = peakfinder)

multisample <- MultiSamplePeakList$new(cor_mpl)
multisample$set_min_scans()
multisample$filter_min_scans()

multisample$sd_fit_function <- peakfinder$peak_finder$sd_fit_function
multisample$sd_predict_function <- peakfinder$peak_finder$sd_predict_function

multisample$calculate_average_mz_model()
```

```{r run_sample_correspondence}
cor_sample <- MasterPeakList$new(multisample, multiplier = 3)
```

```{r how_sparse}
sparseness_value <- function(value_matrix){
  not_na <- sum(is.na(value_matrix))
  total <- nrow(value_matrix) * ncol(value_matrix)
  not_na / total
}

single_sparseness <- sparseness_value(cor_sample$scan_mz)

double_sparseness <- sparseness_value(cor_sample$scan_mz[cor_sample$count_notna() >= 2, ])

triple_sparseness <- sparseness_value(cor_sample$scan_mz[cor_sample$count_notna() >= 3, ])

data_sparcity <- data.frame(perc.sparse = format(c(single_sparseness, double_sparseness, triple_sparseness) * 100, digits = 2),
                            n_sample = c(1, 2, 3))
```

```{r report_sparcity, results='asis'}
knitr::kable(data_sparcity, format = "html")
```

**Note this is in the powerpoint figures document, can't get it to display properly here**

Table 1. Levels of data sparcity based on peak correspondence across `r ncol(cor_sample$scan_mz)` samples.

Table 1 reports the level of data sparcity for an exosomal lipid dataset 
comprised of `r ncol(cor_sample$scan_mz)` samples. The three levels of **n_sample**
denote the differing levels of sparcity if a peak is required to be in at least **n sample**'s.
These values of data sparcity are much lower than the levels of data sparcity that
we have previously observed in data of this type.


```{r sparseness_figure}
frac_notna <- data.frame(nonzero_frac = cor_sample$count_notna() / ncol(cor_sample$scan_mz) )

sparsity_figure <- ggplot(frac_notna, aes(x = nonzero_frac)) + geom_histogram(bins = 29) + scale_y_log10(breaks = c(10, 100, 1000)) + xlab("fraction non-zero")
sparsity_figure
```

Figure 5. Histogram of the log-10 counts of the number of peaks with a given
fraction of sparsity.

Figure 5 shows the distribution of peaks with particular fractions of non-zero entries
across samples. Although the overall distribution is similar in shape to what
has been previously observed, the overall number of peaks with higher fractions
of non-zero entries across samples is much higher than previously observed in
spectrum-level peak picking and assignment-based correspondence analyses. Previous
spectrum-level analyses had generated data sparsity of 0.95 vs 0.75 as shown
in these scan-level analyses.


```{r save_to_file}
library(ReporteRs)
doc <- pptx()

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = single_scan_noiseplot, vector.graphic = TRUE)

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = across_scan_noise, vector.graphic = TRUE)

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = corr_depth_plot, vector.graphic = TRUE)

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = drop_figure, vector.graphic = TRUE)

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addFlexTable(doc, flextable = FlexTable(data_sparcity))

doc <- addSlide(doc, slide.layout = "Content with Caption")
doc <- addPlot(doc = doc, fun = print, x = sparsity_figure, vector.graphic = TRUE)

writeDoc(doc, file = "r03_figures.pptx")
```

